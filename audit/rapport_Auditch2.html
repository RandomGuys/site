   <h2 class="chapterHead"><span class="titlemark">Chapitre 2</span><br /><a 
href="#x9-910002" id="x9-910002">Génération des clefs</a></h2>
<a 
 id="x9-91001r67"></a>
<h3 class="sectionHead"><span class="titlemark">2.1   </span> <a 
href="#x9-920001" id="x9-920001">Déﬁnitions et contexte</a></h3>
<a 
 id="x9-92001r97"></a>
<h4 class="subsectionHead"><span class="titlemark">2.1.1   </span> <a 
href="#x9-930001" id="x9-930001">Clefs cryptographiques</a></h4>
<!--l. 6--><p class="noindent" >La génération de clef est une notion fondamentale de cryptographie. En eﬀet, les données sont protégées grâce à
des algorithmes (ou des méthodes cryptographiques) et des clefs cryptographiques. Les clefs cryptographiques sont
notamment utilisées pour le chiﬀrement et le déchiﬀrement de données. <br 
class="newline" />Relativement aux deux types de cryptographie, on compte deux types de clefs<span class="frenchb-nbsp">&nbsp;</span>: </p>
      <ul class="itemize1">
      <li class="itemize">les clefs symétriques pour le chiﬀrement symétrique<span class="frenchb-thinspace">&nbsp;</span>;
      </li>
      <li class="itemize">les clefs publiques/privées pour le chiﬀrement asymétriques.<br 
class="newline" /></li></ul>
<!--l. 13--><p class="indent" >   On se considérera dans ce chapitre dans un milieu optimal<span class="frenchb-nbsp">&nbsp;</span>:
      </p><ol  class="enumerate1" >
      <li 
  class="enumerate" id="x9-93002x1">l&#x2019;algorithme cryptographique considéré est optimal<span class="frenchb-thinspace">&nbsp;</span>;
      </li>
      <li 
  class="enumerate" id="x9-93004x2">la génération de bits aléatoire est optimale.</li></ol>
<a 
 id="x9-93005r94"></a>
<h5 class="subsubsectionHead"><span class="titlemark">2.1.1.1   </span> <a 
href="#x9-940001" id="x9-940001">Clefs d&#x2019;algorithmes symétriques</a></h5>
<!--l. 21--><p class="noindent" >Les algorithmes symétriques utilisent pour leur chiﬀrement une clef symétrique qui est partagée par chacun des
correspondants.
</p>
   <hr class="figure" /><div class="figure" 
>
                                                                                                  

                                                                                                  
<a 
 id="x9-94001r1"></a>
                                                                                                  

                                                                                                  
<div class="center" 
>
<!--l. 24--><p class="noindent" >
</p><!--l. 43--><p class="noindent" >                                                                          </p><!--l. 34--><p class="noindent" ><span 
class="ec-lmbx-10x-x-109">Échange de messages par chiﬀrement sym</span><span 
class="ec-lmbx-10x-x-109">étrique</span>kkE (Alice)D (Bob)mm<span 
class="lmmi-10x-x-109">E</span><sub><span 
class="lmmi-8">k</span> </sub> <span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmmi-10x-x-109">m</span><span 
class="rm-lmr-10x-x-109">) = </span><span 
class="lmmi-10x-x-109">c</span>
</p></div>
<br /> <div class="caption" 
><span class="id"><span 
class="ec-lmcsc-10x-x-109">Figure</span> 2.1: </span><span  
class="content">Chiﬀrement symétrique - Alice envoie un message <span 
class="lmmi-10x-x-109">c </span>chiﬀré à Bob qui le déchiﬀre</span></div><!--tex4ht:label?: x9-94001r1 -->
                                                                                                  

                                                                                                  
   </div><hr class="endfigure" />
<a 
 id="x9-94002r103"></a>
<h5 class="subsubsectionHead"><span class="titlemark">2.1.1.2   </span> <a 
href="#x9-950002" id="x9-950002">Clefs d&#x2019;algorithmes asymétriques</a></h5>
<!--l. 52--><p class="noindent" >Les clefs d&#x2019;algorithmes symétriques sont de deux catégories, les clefs privées et les clef publiques. Les clefs
publiques sont disponibles pour tous, par demande à l&#x2019;utilisateur, ou bien souvent par certiﬁcat.
</p>
   <hr class="figure" /><div class="figure" 
>
                                                                                                  

                                                                                                  
<a 
 id="x9-95001r2"></a><a 
 id="x9-101001r3"></a><a 
 id="x9-101005r11"></a>
                                                                                                  

                                                                                                  
<div class="center" 
>
<!--l. 55--><p class="noindent" >
</p><!--l. 77--><p class="noindent" >                                                                            </p><!--l. 68--><p class="noindent" ><span 
class="ec-lmbx-10x-x-109">Échange de messages par chiﬀrement asym</span><span 
class="ec-lmbx-10x-x-109">étrique</span><span 
class="lmmi-10x-x-109">k</span><sub><span 
class="lmmi-8">B</span> </sub> <span 
class="lmsy-10x-x-109">′</span>E (Alice)D (Bob)mm<span 
class="lmmi-10x-x-109">k</span><sub><span 
class="lmmi-8">A</span> </sub> (publique), <span 
class="lmmi-10x-x-109">k</span><sub><span 
class="lmmi-8">A</span> </sub> <span 
class="lmsy-10x-x-109">′ </span>(privée)<span 
class="lmmi-10x-x-109">k</span><sub><span 
class="lmmi-8">B</span> </sub> (publique), <span 
class="lmmi-10x-x-109">k</span><sub><span 
class="lmmi-8">B</span> </sub> <span 
class="lmsy-10x-x-109">′ </span>(privée)<span 
class="lmmi-10x-x-109">E</span><sub><span 
class="lmmi-8">k</span><sub><span 
class="lmmi-6">B</span> </sub> </sub> <span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmmi-10x-x-109">m</span><span 
class="rm-lmr-10x-x-109">) = </span><span 
class="lmmi-10x-x-109">c</span>
</p></div>
<br /> <div class="caption" 
><span class="id"><span 
class="ec-lmcsc-10x-x-109">Figure</span> 2.2: </span><span  
class="content">Chiﬀrement asymétrique - Alice envoie un message <span 
class="lmmi-10x-x-109">c </span>chiﬀré à Bob avec sa clef publique qui
le déchiﬀre</span></div><!--tex4ht:label?: x9-95001r2 -->
                                                                                                  

                                                                                                  
   </div><hr class="endfigure" />
<!--l. 83--><p class="indent" >   Comme montré en ﬁgure <a 
href="#x9-95001r2">2.2<!--tex4ht:ref: asym --></a>, Alice chiﬀre avec la clef publique de Bob un message, qui lui-même déchiﬀre le
message avec la clef privée.
<a 
 id="x9-95002r102"></a>
</p>
<h4 class="subsectionHead"><span class="titlemark">2.1.2   </span> <a 
href="#x9-960002" id="x9-960002">Méthode de génération et sécurité</a></h4>
<!--l. 88--><p class="noindent" >Les systèmes utilisent des entiers comme clef. Celles-ci sont générées en utilisant des générateurs de nombres
aléatoires (RNG) ou des générateurs de nombres pseudo aléatoires (PRNG).
<a 
 id="x9-96001r105"></a>
</p>
<h5 class="subsubsectionHead"><span class="titlemark">2.1.2.1   </span> <a 
href="#x9-970001" id="x9-970001">Génération de clefs quelconques</a></h5>
<!--l. 91--><p class="noindent" >Un générateur de bits aléatoires (RGB) approuvé est utilisé pour générer la clef cryptographique. Le RGB doit
fournir une entropie complète ou suﬃsante aux exigences de sécurité du système. Les RGB peuvent permettre de
générer complètement et &#x0022;directement&#x0022; la clef. C&#x2019;est le cas pour les clefs privées des algorithmes AES ou DSA. Les
RGB peuvent aussi être utilisés comme <span 
class="ec-lmri-10x-x-109">seed </span>pour générer des clefs, suivants des critères spéciﬁques. C&#x2019;est le cas
pour RSA, où habituellement le <span 
class="ec-lmri-10x-x-109">seed </span>est utilisé comme point de départ pour trouver un nombre premier suivant les
critères du FIPS 186-3 <span class="cite">[<span 
class="ec-lmbx-10x-x-109">?</span>]</span>.
<a 
 id="x9-97001r108"></a>
</p>
<h5 class="subsubsectionHead"><span class="titlemark">2.1.2.2   </span> <a 
href="#x9-980002" id="x9-980002">Génération de paires de clefs asymétriques</a></h5>
<!--l. 95--><p class="noindent" >Les algorithmes asymétriques demandent la création de paires de clefs asymétriques (privée/publique), dont
chaque clef est associée à une seule entité, le possesseur de la clef. Les clefs sont généralement générées
par son possesseur direct, ou par une autorité de conﬁance qui fournit la clef au possesseur de façon
sûre.<br 
class="newline" />Il convient au moment de la génération de bien considérer deux paramètres principaux<span class="frenchb-nbsp">&nbsp;</span>:
      </p><ol  class="enumerate1" >
      <li 
  class="enumerate" id="x9-98002x1">l&#x2019;espace de clefs, qui doit être suﬃsamment grand pour éviter les doublons et les cycles<span class="frenchb-thinspace">&nbsp;</span>;
      </li>
      <li 
  class="enumerate" id="x9-98004x2">Générer les premiers de façon la plus aléatoire possible. Ceci nécessite un bon choix de stratégie
      d&#x2019;identiﬁcation de premiers. On peut par exemple utiliser des algorithmes permettant de détecter le
      prochain premier, suivant un entier tiré aléatoirement.</li></ol>
<a 
 id="x9-98005r101"></a>
<h3 class="sectionHead"><span class="titlemark">2.2   </span> <a 
href="#x9-990002" id="x9-990002">Audits</a></h3>
<a 
 id="x9-99001r107"></a>
<h4 class="subsectionHead"><span class="titlemark">2.2.1   </span> <a 
href="#x9-1000001" id="x9-1000001">Audit 2.1<span class="frenchb-nbsp">&nbsp;</span>: Génération d&#x2019;entiers premiers, et de grands nombres</a></h4>
<a 
 id="x9-100001r109"></a>
<h5 class="subsubsectionHead"><span class="titlemark">2.2.1.1   </span> <a 
href="#x9-1010001" id="x9-1010001">Description de la librairie BIGNUMBER</a></h5>
<!--l. 109--><p class="noindent" >OpenSSL gère l&#x2019;arithmétique multi-précison (gestion des grands entier) avec sa librairie BIGNUMBER.
La taille de ces entiers est arbitraire, il n&#x2019;y a théoriquement pas de limitation de taille. Elle a été
spécialement créée aﬁn d&#x2019;utiliser des systèmes cryptographiques à clefs publiques tels que RSA ou
Diﬃe-Hellman.<br 
class="newline" />
</p><!--l. 111--><p class="indent" >   Pour le stockage de grands entiers, elle utilise directement et dynamiquement la mémoire comme structure de
données. Le code de retour est un entier permettant de vériﬁer l&#x2019;état de la mémoire après chaque
opération.<br 
class="newline" />
</p><!--l. 113--><p class="indent" >   Le type de données pour ces grands entiers est une structure ayant pour nom BIGNUM. Cette structure peut
être directement utilisée en incluant la bibliothèque <span 
class="ec-lmtt-10x-x-109">openssl/crypto/bn/bn.h</span>.<br 
class="newline" />
</p><!--l. 115--><p class="indent" >   La structure générale d&#x2019;un BIGNUM est déﬁnie dans le ﬁchier <span 
class="ec-lmtt-10x-x-109">openssl/crypto/ossl_typ.h</span>, (cf. <span 
class="ec-lmri-10x-x-109">Listing </span><a 
href="#x9-101001r1">2.1<!--tex4ht:ref: ossltyp --></a>),
et elle est implantée dans le ﬁchier <span 
class="ec-lmtt-10x-x-109">openssl/crypto/bn/bn.h </span>(cf. <span 
class="ec-lmri-10x-x-109">Listing </span><a 
href="#x9-101005r2">2.2<!--tex4ht:ref: bn --></a>). Un schéma explicatif est déﬁni sur
<span 
class="ec-lmri-10x-x-109">Listing </span><a 
href="#x9-101017r3">2.3<!--tex4ht:ref: bignum --></a>.
</p>
   <!--l. 117-->
<pre>
typedef struct bignum_st BIGNUM; 
</pre>
       <div class="caption" 
><span class="id">Listing 2.1:
       </span><span  
class="content">ossl_typ.h</span></div><!--tex4ht:label?: x9-101001r2 -->
   <!--l. 121-->
<pre>
struct bignum_st       
{      
  BN_ULONG *d;  /* Pointer to an array of ’BN_BITS2’ bit chunks. */
  int top;  /* Index of last used d +1. */
  /* The next are internal book keeping for bn_expand. */
  int dmax; /* Size of the d array. */
  int neg;  /* one if the number is negative */
  int flags;
};

</pre>
       <div class="caption" 
><span class="id">Listing 2.2:
       </span><span  
class="content">bn.h</span></div><!--tex4ht:label?: x9-101005r2 -->
   <hr class="figure" /><div class="figure" 
>
                                                                                                  

                                                                                                  
<a 
 id="x9-101017r3"></a><a 
 id="x9-101018r20"></a><a 
 id="x9-115001r39"></a><a 
 id="x9-122001r8"></a>
                                                                                                  

                                                                                                  
<div class="center" 
>
<!--l. 134--><p class="noindent" >
</p><!--l. 166--><p class="noindent" >                                                                            </p><!--l. 154--><p class="noindent" ><span 
class="ec-lmbx-10x-x-109">Structure d&#x2019;un big number</span>d.d[0]d[1]d[max]8 octetsnegnégatif, si vaut 1positif, sinontopposition courante+1
</p></div>
<br /> <div class="caption" 
><span class="id"><span 
class="ec-lmcsc-10x-x-109">Figure</span> 2.3: </span><span  
class="content">Structure d&#x2019;un BIGNUM</span></div><!--tex4ht:label?: x9-101017r3 -->
                                                                                                  

                                                                                                  
   </div><hr class="endfigure" />
<!--l. 172--><p class="indent" >   Il existe des structures variantes de BIGNUM pour d&#x2019;autres cas d&#x2019;utilisation (Montgomery, Division réciproque,
génération lente).<br 
class="newline" />
</p><!--l. 174--><p class="indent" >   La création d&#x2019;une nouvelle structure de type BIGNUM se situe dans le ﬁchier <span 
class="ec-lmtt-10x-x-109">openssl/crypto/bn/bn_lib.h</span>, la
fonction se nomme <span 
class="ec-lmtt-10x-x-109">BN_new() </span>(cf. <span 
class="ec-lmri-10x-x-109">Listing </span><a 
href="#x9-101018r3">2.3<!--tex4ht:ref: bnlib --></a>).<br 
class="newline" />
</p>
   <!--l. 176-->
<pre>
BIGNUM *BN_new(void) 
{ 
    BIGNUM *ret; 

    if ((ret=(BIGNUM *)OPENSSL_malloc(sizeof(BIGNUM))) == NULL) 
    { 
        BNerr(BN_F_BN_NEW,ERR_R_MALLOC_FAILURE); 
        return(NULL); 
    } 
    ret->flags=BN_FLG_MALLOCED; 
    ret->top=0; 
    ret->neg=0; 
    ret->dmax=0; 
    ret->d=NULL; 
    bn_check_top(ret); 
    return(ret); 
} 
</pre>
       <div class="caption" 
><span class="id">Listing 2.3:
       </span><span  
class="content">bn_lib.c</span></div><!--tex4ht:label?: x9-101018r2 -->
<a 
 id="x9-101039r112"></a>
<h5 class="subsubsectionHead"><span class="titlemark">2.2.1.2   </span> <a 
href="#x9-1020002" id="x9-1020002">Normes visées</a></h5>
<!--l. 199--><p class="noindent" >Plusieurs fonctions désignent directement la norme visée, voici quelques exemples sur les thèmes nous concernant
pour l&#x2019;audit.<br 
class="newline" />Sur la génération de groupes d&#x2019;exponentiation modulaire de Diﬃe-Hellman allant de 768bits à 8192bits, les RFC
visées <span class="cite">[<span 
class="ec-lmbx-10x-x-109">?</span>]</span> <span class="cite">[<span 
class="ec-lmbx-10x-x-109">?</span>]</span> ont leurs fonctions implantées dans le code<span class="frenchb-nbsp">&nbsp;</span>: </p>
      <ul class="itemize1">
      <li class="itemize">BIGNUM *get_rfc2409_prime_768(BIGNUM *bn)<span class="frenchb-thinspace">&nbsp;</span>;
      </li>
      <li class="itemize">BIGNUM *get_rfc2409_prime_1024(BIGNUM *bn)<span class="frenchb-thinspace">&nbsp;</span>;
      </li>
      <li class="itemize">BIGNUM *get_rfc3526_prime_1536(BIGNUM *bn)<span class="frenchb-thinspace">&nbsp;</span>;
      </li>
      <li class="itemize">BIGNUM *get_rfc3526_prime_2048(BIGNUM *bn)<span class="frenchb-thinspace">&nbsp;</span>;
      </li>
      <li class="itemize">BIGNUM *get_rfc3526_prime_3072(BIGNUM *bn)<span class="frenchb-thinspace">&nbsp;</span>;
      </li>
      <li class="itemize">BIGNUM *get_rfc3526_prime_4096(BIGNUM *bn)<span class="frenchb-thinspace">&nbsp;</span>;
      </li>
      <li class="itemize">BIGNUM *get_rfc3526_prime_6144(BIGNUM *bn)<span class="frenchb-thinspace">&nbsp;</span>;
      </li>
      <li class="itemize">BIGNUM *get_rfc3526_prime_8192(BIGNUM *bn)<span class="frenchb-thinspace">&nbsp;</span>;</li></ul>
<!--l. 212--><p class="noindent" ><span class="paragraphHead"><a 
href="#x9-1030002" id="x9-1030002"><span 
class="ec-lmbx-10x-x-109">RFC 2409</span><span class="frenchb-nbsp">&nbsp;</span><span 
class="ec-lmbx-10x-x-109">: Internet Key Exchange</span><br 
class="newline" /></a></span>
   La RFC 2409 <span class="cite">[<span 
class="ec-lmbx-10x-x-109">?</span>]</span> datant de 1998, donne deux implantations de fonctions récupérant des entiers premiers de plus
de 768bits et de plus de 1024bits. Elles se nomment respectivement le premier groupe d&#x2019;Oakley et le second groupe
                                                                                                  

                                                                                                  
d&#x2019;Oakley.<br 
class="newline" />
</p><!--l. 216--><p class="indent" >   Un groupe MODP (Modular exponentiation group) est un groupe d&#x2019;exponentiation modulaire.
<br 
class="newline" />
</p><!--l. 218--><p class="indent" >   Pour le groupe MODP sur 768bits (groupe par défaut qui DOIT être le minimum requis) le groupe utilise
comme nombre premier<span class="frenchb-nbsp">&nbsp;</span>:
</p>
   <center class="math-display" >
<img 
src="audit/rapport_Audit44x.png" alt=" 768   704       64     638
2   − 2   −  1+ 2  ∗ {[2    pi] + 149686} " class="math-display"  /></center> Et
comme générateur<span class="frenchb-nbsp">&nbsp;</span>: 2.<br 
class="newline" />
<!--l. 222--><p class="indent" >   Pour le groupe MODP sur 1024bits (groupe alternatif qui DEVRAIT être le groupe utilisé) le groupe utilise
comme nombre premier<span class="frenchb-nbsp">&nbsp;</span>:
</p>
   <center class="math-display" >
<img 
src="audit/rapport_Audit45x.png" alt="21024 − 2960 − 1+  264 ∗{[2894 pi]+ 129093} " class="math-display"  /></center> Et
comme générateur<span class="frenchb-nbsp">&nbsp;</span>: 2. <br 
class="newline" />
<!--l. 226--><p class="indent" >   La RFC 2412<span class="frenchb-nbsp">&nbsp;</span>: OAKLEY Key Determination Protocol datant de 1998 également <span class="cite">[<span 
class="ec-lmbx-10x-x-109">?</span>]</span> préconise plutôt d&#x2019;utiliser
22 comme générateur.
</p>
<!--l. 228--><p class="noindent" ><span class="paragraphHead"><a 
href="#x9-1040002" id="x9-1040002"><span 
class="ec-lmbx-10x-x-109">RFC 3526</span><span class="frenchb-nbsp">&nbsp;</span><span 
class="ec-lmbx-10x-x-109">: More Modular Exponential (MODP) Diﬃe-Hellman groups for Internet Key Exchange</span>
<span 
class="ec-lmbx-10x-x-109">(IKE)</span><br 
class="newline" /></a></span>
   La RFC 3526 <span class="cite">[<span 
class="ec-lmbx-10x-x-109">?</span>]</span> complète la RFC 2409. Elle déﬁnit les groupes MODP sur 1536, 2048, 3072, 4096, 6144 et 8192
bits.<br 
class="newline" />
                                                                                                  

                                                                                                  
</p><!--l. 232--><p class="indent" >   <span 
class="ec-lmri-10x-x-109">Exemple avec 2048 bits</span><span class="frenchb-nbsp">&nbsp;</span><span 
class="ec-lmri-10x-x-109">:</span><br 
class="newline" />Le nombre premier vaut<span class="frenchb-nbsp">&nbsp;</span>:
</p>
   <center class="math-display" >
<img 
src="audit/rapport_Audit46x.png" alt=" 2048   1984        64     1918
2    − 2    − 1+  2  ∗{[2    pi]+ 124476} " class="math-display"  /></center> Le
générateur vaut<span class="frenchb-nbsp">&nbsp;</span>: 2<br 
class="newline" />
<!--l. 237--><p class="indent" >   Sur la génération de nombres premiers, nous nous basons sur la RFC 2631 qui utilise les recommandations du
FIPS 140-1 que l&#x2019;on déﬁni dans la section <span 
class="ec-lmbx-10x-x-109">??</span>
<a 
 id="x9-104001r117"></a>
</p>
<h5 class="subsubsectionHead"><span class="titlemark">2.2.1.3   </span> <a 
href="#x9-1050003" id="x9-1050003">Implémentation</a></h5>
<!--l. 241--><p class="noindent" ><span class="paragraphHead"><a 
href="#x9-1060003" id="x9-1060003"><span 
class="ec-lmbx-10x-x-109">Version vis</span><span 
class="ec-lmbx-10x-x-109">ée. </span><br 
class="newline" /></a></span>
   La version auditée est OpenSSL 1.0.0l sortie le 6 Janvier 2014.
</p>
<!--l. 245--><p class="noindent" ><span class="paragraphHead"><a 
href="#x9-1070003" id="x9-1070003"><span 
class="ec-lmbx-10x-x-109">Exemples de fonctions. </span><br 
class="newline" /></a></span>
   Les ﬁchiers <span 
class="ec-lmtt-10x-x-109">bn_add.c</span>, <span 
class="ec-lmtt-10x-x-109">bn_exp.c</span>, <span 
class="ec-lmtt-10x-x-109">bn_div.c</span>, <span 
class="ec-lmtt-10x-x-109">bn_mul.c</span>, etc, présents dans le paquetage <span 
class="ec-lmtt-10x-x-109">openssl/crypto/bn</span>
contiennent des fonctions arithmétiques simples (addition, multiplication, soustraction, exponentiaition, etc)
utilisant la structure BIGNUM.
</p>
<!--l. 249--><p class="noindent" ><span class="paragraphHead"><a 
href="#x9-1080003" id="x9-1080003"><span 
class="ec-lmbx-10x-x-109">Analyse de la g</span><span 
class="ec-lmbx-10x-x-109">én</span><span 
class="ec-lmbx-10x-x-109">ération d&#x2019;entiers premiers.</span><br 
class="newline" /></a></span>
   La génération des entiers premiers se fait au sein du ﬁchier <span 
class="ec-lmtt-10x-x-109">openssl/crypto/bn/bn_prime.c</span>. Parmi les
fonctions intéressantes nous avons<span class="frenchb-nbsp">&nbsp;</span>: </p>
      <ul class="itemize1">
      <li class="itemize">int BN_generate_prime_ex(BIGNUM *ret, int bits, int safe, const BIGNUM *add, const BIGNUM
      *rem, BN_GENCB *cb)<span class="frenchb-thinspace">&nbsp;</span>;
                                                                                                  

                                                                                                  
      </li>
      <li class="itemize">int BN_is_prime_ex(const BIGNUM *p,int nchecks, BN_CTX *ctx, BN_GENCB *cb)<span class="frenchb-thinspace">&nbsp;</span>;
      </li>
      <li class="itemize">int BN_is_prime_fasttest_ex(const BIGNUM *p,int nchecks, BN_CTX *ctx, int do_trial_division,
      BN_GENCB *cb)<span class="frenchb-thinspace">&nbsp;</span>;<br 
class="newline" /></li></ul>
<!--l. 258--><p class="indent" >   <span 
class="ec-lmri-10x-x-109">int BN_generate_prime_ex(BIGNUM *ret, int bits, int safe, const BIGNUM *add, const BIGNUM *rem,</span>
<span 
class="ec-lmri-10x-x-109">BN_GENCB *cb)</span><span class="frenchb-thinspace">&nbsp;</span><span 
class="ec-lmri-10x-x-109">;</span> </p>
      <ul class="itemize1">
      <li class="itemize">génère un nombre premier aléatoire de <span 
class="ec-lmri-10x-x-109">bits </span>bits<span class="frenchb-thinspace">&nbsp;</span>;
      </li>
      <li class="itemize">si <span 
class="ec-lmri-10x-x-109">ret </span>vaut <span 
class="lmmi-10x-x-109">NULL </span>alors l&#x2019;entier n&#x2019;est pas stocké, sinon il est stocké sur le descripteur de la structure
      BIGNUM<span class="frenchb-thinspace">&nbsp;</span>;
      </li>
      <li class="itemize">si <span 
class="ec-lmri-10x-x-109">cb </span>n&#x2019;est pas <span 
class="lmmi-10x-x-109">NULL </span>il servira à générer un <span 
class="ec-lmri-10x-x-109">callback </span>lors de la génération du i-ème nombre premier
      potentiel, lors du test de primalité et lorsqu&#x2019;un entier premier à été trouvé<span class="frenchb-thinspace">&nbsp;</span>;
      </li>
      <li class="itemize">d&#x2019;après la RFC 2631 <span class="cite">[<span 
class="ec-lmbx-10x-x-109">?</span>]</span> et en particulier les parties concernant le FIPS 186-1 <span class="cite">[<span 
class="ec-lmbx-10x-x-109">?</span>]</span>, le paramètre
      <span 
class="ec-lmri-10x-x-109">add </span>permet de vériﬁer la condition<span class="frenchb-nbsp">&nbsp;</span>: <span 
class="lmmi-10x-x-109">pmodadd </span><span 
class="rm-lmr-10x-x-109">== </span><span 
class="lmmi-10x-x-109">rem</span><span 
class="lmsy-10x-x-109">||</span><span 
class="lmmi-10x-x-109">pmodadd </span><span 
class="rm-lmr-10x-x-109">== 1</span><span 
class="lmmi-10x-x-109"> Si</span><span 
class="lmmi-10x-x-109"> rem </span><span 
class="rm-lmr-10x-x-109">== </span><span 
class="lmmi-10x-x-109">NULL</span><span 
class="rm-lmr-10x-x-109">) </span>et le
      paramètre <span 
class="ec-lmri-10x-x-109">safe </span>vaut <span 
class="ec-lmri-10x-x-109">true </span>pour la déﬁnition d&#x2019;un nombre premier sûr, e.g qu&#x2019;il résiste à certaines
      attaques cryptanalytiques (i.e un entier premier p dont <span 
class="rm-lmr-10x-x-109">(</span><span 
class="lmmi-10x-x-109">p </span><span 
class="lmsy-10x-x-109">− </span><span 
class="rm-lmr-10x-x-109">1)</span><span 
class="lmmi-10x-x-109">∕</span><span 
class="rm-lmr-10x-x-109">2 </span>est également premier est sûr)<span class="frenchb-thinspace">&nbsp;</span>;
      </li>
      <li class="itemize">attention avant d&#x2019;utiliser la fonction ci-dessus à bien passer une graine au PRNG<span class="frenchb-thinspace">&nbsp;</span>;
      </li>
      <li class="itemize">la génération d&#x2019;un nombre premier a une probabilité d&#x2019;échec négligeable (0.25% d&#x2019;échecs possibles
      puissance le nombre de tentatives)<span class="frenchb-thinspace">&nbsp;</span>;
      </li>
      <li class="itemize">la fonction retourne &#x2019;1&#x2019; si la génération est un succès, &#x2019;0&#x2019; sinon.<br 
class="newline" /></li></ul>
<!--l. 269--><p class="indent" >   <span 
class="ec-lmri-10x-x-109">int BN_prime_ex(const BIGNUM *p,int nchecks, BN_CTX *ctx, BN_GENCB *cb)</span><span class="frenchb-thinspace">&nbsp;</span><span 
class="ec-lmri-10x-x-109">;</span> </p>
      <ul class="itemize1">
      <li class="itemize">fonction de test de primalité sur l&#x2019;entier <span 
class="ec-lmri-10x-x-109">p</span><span class="frenchb-thinspace">&nbsp;</span>;
      </li>
      <li class="itemize">nbchecks est le nombre de tests à eﬀectuer<span class="frenchb-thinspace">&nbsp;</span>;
      </li>
      <li class="itemize"><span 
class="ec-lmri-10x-x-109">cb </span>s&#x2019;il n&#x2019;est pas <span 
class="lmmi-10x-x-109">NULL </span>génère un callback à chaque j-ème itération dans le code<span class="frenchb-thinspace">&nbsp;</span>;
      </li>
      <li class="itemize"><span 
class="ec-lmri-10x-x-109">ctx </span>s&#x2019;il n&#x2019;est pas <span 
class="lmmi-10x-x-109">NULL </span>est utilisé pour sauvegarder l&#x2019;allocation du dessus et libérer la structure<span class="frenchb-thinspace">&nbsp;</span>;
      </li>
      <li class="itemize">la fonction retourne 0 si le nombre est premier avec une probabilité de 100%, 1 si la probabilité est
      plus faible que <span 
class="rm-lmr-10x-x-109">0</span><span 
class="lmmi-10x-x-109">.</span><span 
class="rm-lmr-10x-x-109">25</span><sup><span 
class="lmmi-8">n</span></sup><span 
class="lmmi-10x-x-109">checks</span>, et -1 sinon.<br 
class="newline" /></li></ul>
<!--l. 278--><p class="indent" >   <span 
class="ec-lmri-10x-x-109">int BN_is_prime_fasttest_ex(const BIGNUM *p,int nchecks, BN_CTX *ctx, int do_trial_division,</span>
<span 
class="ec-lmri-10x-x-109">BN_GENCB *cb)</span><span class="frenchb-thinspace">&nbsp;</span><span 
class="ec-lmri-10x-x-109">;</span> </p>
      <ul class="itemize1">
                                                                                                  

                                                                                                  
      <li class="itemize">cette fonction fait exactement la même chose que la fonction précédente<span class="frenchb-thinspace">&nbsp;</span>;
      </li>
      <li class="itemize">mais si <span 
class="ec-lmri-10x-x-109">do_trial_division </span>vaut &#x2019;1&#x2019; il testera avant s&#x2019;il n&#x2019;est pas divisible par des petits nombres entiers,
      s&#x2019;il vaut &#x2019;0&#x2019; cela revient à appeler la fonction <span 
class="ec-lmri-10x-x-109">BN_prime_ex</span></li></ul>
<a 
 id="x9-108001r120"></a>
<h5 class="subsubsectionHead"><span class="titlemark">2.2.1.4   </span> <a 
href="#x9-1090004" id="x9-1090004">Conclusion</a></h5>
     Sur la présentation des diﬀérentes structures et des diﬀérentes opérations arithmétiques revisitées, la
documentation est plus complète et plus claire que les autres fonctions auditées en général, même s&#x2019;il reste à
notre avis des eﬀorts sur la mise en forme. Le découpage des fonctions est bien fait au sein du dossier
<span 
class="ec-lmtt-10x-x-109">openssl/crypto/bn </span>avec des noms de ﬁchiers cohérents, et au sein des ﬁchiers avec des explications sur les
diﬀérentes structures et des noms de fonctions cohérentes également même si on aurait préféré une ligne
d&#x2019;explications en en-tête de chaque fonction. Lors de l&#x2019;audit, on retrouvait rapidement le code concernant une
fonction.<br 
class="newline" />
   Sur le contenu, les normes sont bien respectées, notamment pour la génération des nombres premiers qui utilise
les tests de primalité de Miller-Rabin, réputés sûrs.
<a 
 id="x9-109001r111"></a>
<h4 class="subsectionHead"><span class="titlemark">2.2.2   </span> <a 
href="#x9-1100002" id="x9-1100002">Audit 2.2<span class="frenchb-nbsp">&nbsp;</span>: Le générateur de Diﬃe-Hellman</a></h4>
<a 
 id="x9-110001r124"></a>
<h5 class="subsubsectionHead"><span class="titlemark">2.2.2.1   </span> <a 
href="#x9-1110001" id="x9-1110001">Normes visées</a></h5>
<!--l. 295--><p class="noindent" >Voici l&#x2019;algorithme de génération de g, d&#x2019;après la RFC 2631 <span class="cite">[<span 
class="ec-lmbx-10x-x-109">?</span>]</span> datant de 1999 et dérivé de la FIPS-186<span class="frenchb-nbsp">&nbsp;</span>:
</p>
      <ul class="itemize1">
      <li class="itemize">1- Soit <span 
class="lmmi-10x-x-109">j </span><span 
class="rm-lmr-10x-x-109">= (</span><span 
class="lmmi-10x-x-109">p </span><span 
class="lmsy-10x-x-109">− </span><span 
class="rm-lmr-10x-x-109">1)</span><span 
class="lmmi-10x-x-109">∕q</span>.
      </li>
      <li class="itemize">2- Choisir <span 
class="lmmi-10x-x-109">h </span><span 
class="lmsy-10x-x-109">∈ </span><span 
class="msbm-10x-x-109">ℕ</span>, tel que <span 
class="rm-lmr-10x-x-109">1 </span><span 
class="lmmi-10x-x-109">&#x003C; h &#x003C; p </span><span 
class="lmsy-10x-x-109">− </span><span 
class="rm-lmr-10x-x-109">1</span>
      </li>
      <li class="itemize">3- Calculer <span 
class="lmmi-10x-x-109">g </span><span 
class="rm-lmr-10x-x-109">= </span><span 
class="lmmi-10x-x-109">h</span><sup><span 
class="lmmi-8">j</span></sup>  <span 
class="rm-lmr-10x-x-109">mod</span><span style="margin-left:0.3em" class="thinspace"></span><span style="margin-left:0.3em" class="thinspace"></span><span 
class="lmmi-10x-x-109">p</span>
      </li>
      <li class="itemize">4- Si <span 
class="lmmi-10x-x-109">g </span><span 
class="rm-lmr-10x-x-109">= 1 </span>recommencer l&#x2019;étape 2<br 
class="newline" /></li></ul>
<!--l. 303--><p class="indent" >   Mais depuis 2006, on peut lire comme recommandation dans la RFC 4419 (pour une utilisation SSH)<span class="frenchb-nbsp">&nbsp;</span>: &#x0022;<span 
class="ec-lmri-10x-x-109">It is</span>
<span 
class="ec-lmri-10x-x-109">recommended to use 2 as generator, because it improves eﬃciency in multiplication performance. It is usable even</span>
<span 
class="ec-lmri-10x-x-109">when itis not a primitive root, as it still covers half of the space of possible residues.</span>&#x0022;<br 
class="newline" />
<a 
 id="x9-111001r126"></a>
</p>
<h5 class="subsubsectionHead"><span class="titlemark">2.2.2.2   </span> <a 
href="#x9-1120002" id="x9-1120002">Description de la faille</a></h5>
<!--l. 307--><p class="noindent" >Lorsque nous avons étudié le code de Diﬃe-Hellman dans OpenSSL, nous nous sommes penchés sur un choix plutôt
étrange. La valeur du générateur est toujours ﬁxé à 2 ou à 5. <br 
class="newline" />
                                                                                                  

                                                                                                  
</p><!--l. 309--><p class="indent" >   Le générateur de Diﬃe-Hellman n&#x2019;étant pas une racine primitive dans <span 
class="msbm-10x-x-109">ℤ</span><span 
class="lmmi-10x-x-109">∕</span><span 
class="msbm-10x-x-109">ℤ</span><sub><span 
class="lmmi-8">p</span></sub>, les conséquences sont<span class="frenchb-nbsp">&nbsp;</span>:
</p>
      <ul class="itemize1">
      <li class="itemize">l&#x2019;espace des clefs possibles est fortement réduit (Si <span 
class="lmmi-10x-x-109">g </span><span 
class="rm-lmr-10x-x-109">= 2</span><span style="margin-left:3.04074pt" class="tmspace"></span><img 
src="audit/rapport_Audit47x.png" alt="=⇒"  class="Longrightarrow"  /><span style="margin-left:3.04074pt" class="tmspace"></span> espace divisé par deux)<span class="frenchb-thinspace">&nbsp;</span>;
      </li>
      <li class="itemize">deux clefs privées distinctes pourront avoir une clef publique commune<span class="frenchb-thinspace">&nbsp;</span>;
      </li>
      <li class="itemize">la méthode de cryptanalyse Baby-step Giant-step peut s&#x2019;en trouver facilité.<br 
class="newline" /></li></ul>
<!--l. 316--><p class="indent" >   Évidemment, ce choix n&#x2019;est pas une faille en soit, il n&#x2019;est juste pas optimal et résulte d&#x2019;un bon compromis
entre vitesse et sécurité. Pour une sécurité optimale, il est conseillé de choisir un générateur qui soit
une racine primitive, pour être certain que personne ne puisse signer, déchiﬀrer des messages à votre
place<span class="frenchb-thinspace">&nbsp;</span>!<br 
class="newline" />
<a 
 id="x9-112001r127"></a>
</p>
<h5 class="subsubsectionHead"><span class="titlemark">2.2.2.3   </span> <a 
href="#x9-1130003" id="x9-1130003">Implémentation</a></h5>
<!--l. 321--><p class="noindent" ><span class="paragraphHead"><a 
href="#x9-1140003" id="x9-1140003"><span 
class="ec-lmbx-10x-x-109">Conﬁguration vis</span><span 
class="ec-lmbx-10x-x-109">ée.</span><br 
class="newline" /></a></span>
   La version actuelle d&#x2019;OpenSSL<span class="frenchb-nbsp">&nbsp;</span>: 1.1.0
</p>
<!--l. 325--><p class="noindent" ><span class="paragraphHead"><a 
href="#x9-1150003" id="x9-1150003"><span 
class="ec-lmbx-10x-x-109">Fonction.</span><br 
class="newline" /></a></span>
   La fonction liée à cette norme est accessible sous le paquetage <span 
class="ec-lmtt-10x-x-109">openssl/crypto/dh/dh_gen.c </span>(cf. <span 
class="ec-lmri-10x-x-109">Listing </span><a 
href="#x9-115001r4">2.4<!--tex4ht:ref: dhgen --></a>).
Les commentaires sont très intéressants pour comprendre le choix du générateur par l&#x2019;équipe de
développement.
</p>
   <!--l. 329-->
<pre>
if (generator <= 1) 
{ 
    DHerr(DH_F_DH_BUILTIN_GENPARAMS, DH_R_BAD_GENERATOR); 
    goto err; 
} 
if (generator == DH_GENERATOR_2) 
{ 
    if (!BN_set_word(t1,24)) goto err; 
    if (!BN_set_word(t2,11)) goto err; 
g=2; 
} 
#if 0 /* does not work for safe primes */ 
else if (generator == DH_GENERATOR_3) 
{ 
    if (!BN_set_word(t1,12)) goto err; 
    if (!BN_set_word(t2,5)) goto err; 
    g=3; 
} 
#endif 
else if (generator == DH_GENERATOR_5) 
{ 
    if (!BN_set_word(t1,10)) goto err; 
    if (!BN_set_word(t2,3)) goto err; 
    /* BN_set_word(t3,7); just have to miss 
     * out on these ones :-( */ 
    g=5; 
} 
else 
{ 
    /* in the general case, don’t worry if ’generator’ is a 
     * generator or not: since we are using safe primes, 
     * it will generate either an order-q or an order-2q group, 
     * which both is OK */ 
    if (!BN_set_word(t1,2)) goto err; 
    if (!BN_set_word(t2,1)) goto err; 
    g=generator; 
} 
</pre>   
       <div class="caption" 
><span class="id">Listing 2.4:
       </span><span  
class="content">dh_gen.c</span></div><!--tex4ht:label?: x9-115001r2 -->
<a 
 id="x9-115041r128"></a>
<h5 class="subsubsectionHead"><span class="titlemark">2.2.2.4   </span> <a 
href="#x9-1160004" id="x9-1160004">Conclusion</a></h5>
     Ainsi selon la norme RFC-4419, le choix du générateur peut se résumer à un petit générateur qui ne serait pas
une racine primitive. La criticité du risque est très grande, car si deux personnes possèdent la même clef publique
                                                                                                  

                                                                                                  
pour deux clefs privées distinctes, ils pourront alors déchiﬀrer les messages, et signer à la place l&#x2019;un de l&#x2019;autre. Mais
la probabilité d&#x2019;une telle collision est quasiment nulle, il est simplement deux fois plus eﬃcace de générer deux clefs
privées possédant la même clef publique, que de retrouver la clef privée en brute force. OpenSSL laisse en plus
le choix au développeur de choisir une racine primitive comme générateur, pour des cas d&#x2019;extrême
sécurité.
<a 
 id="x9-116001r125"></a>
<h4 class="subsectionHead"><span class="titlemark">2.2.3   </span> <a 
href="#x9-1170003" id="x9-1170003">Audit 2.3<span class="frenchb-nbsp">&nbsp;</span>: Diﬃe-Hellman Ephémère en mode FIPS</a></h4>
<a 
 id="x9-117001r132"></a>
<h5 class="subsubsectionHead"><span class="titlemark">2.2.3.1   </span> <a 
href="#x9-1180001" id="x9-1180001">Normes visées</a></h5>
<!--l. 377--><p class="noindent" >Les normes visées sont les mêmes que celles de l&#x2019;Audit 2.2 (cf. <a 
href="#x9-1110001">2.2.2.1<!--tex4ht:ref: audit2.2 --></a>).<br 
class="newline" />L&#x2019;activation du mode FIPS entraîne l&#x2019;utilisation des normes FIPS <span class="cite">[<span 
class="ec-lmbx-10x-x-109">?</span>]</span> <span class="cite">[<span 
class="ec-lmbx-10x-x-109">?</span>]</span>
<a 
 id="x9-118001r134"></a>
</p>
<h5 class="subsubsectionHead"><span class="titlemark">2.2.3.2   </span> <a 
href="#x9-1190002" id="x9-1190002">Description de la faille</a></h5>
<!--l. 382--><p class="noindent" >Une faille plus grave concerne le mode FIPS (Federal Information Processing Standard) d&#x2019;OpenSSL, qui peut
être compilé avec la commande <span 
class="ec-lmtt-10x-x-109">./config fipscanisterbuild</span>&#x0022;. En eﬀet, un attaquant situé entre
le client et le serveur connaissant la clef secrète du serveur peut déchiﬀrer une session SSL/TLS.
<br 
class="newline" />
</p><!--l. 384--><p class="indent" >   L&#x2019;algorithme EDH/DHE (Diﬃe-Hellman Éphémère) permet de calculer une nouvelle clef connue
uniquement du client et du serveur, donc l&#x2019;attaquant intermédiaire ne peut plus déchiﬀrer la session.
Cependant, en mode FIPS, OpenSSL ne rejette pas les paramètres P/Q faibles pour EDH/DHE.
Lorsque OpenSSL est compilé en mode FIPS, un attaquant en <span 
class="ec-lmri-10x-x-109">Man in the Middle </span>peut donc forcer
la génération d&#x2019;un secret Diﬃe Hellman prédictible, en modiﬁant par exemple le traﬃc réseau. <span class="cite">[<span 
class="ec-lmbx-10x-x-109">?</span>]</span>
<span class="cite">[<span 
class="ec-lmbx-10x-x-109">?</span>]</span>.
</p><!--l. 386--><p class="indent" >   La faille en elle même n&#x2019;est pas suﬃsante pour réaliser l&#x2019;attaque, elle requiert également une implémentation
SSL faible.
<a 
 id="x9-119001r135"></a>
</p>
<h5 class="subsubsectionHead"><span class="titlemark">2.2.3.3   </span> <a 
href="#x9-1200003" id="x9-1200003">Implémentation</a></h5>
<!--l. 390--><p class="noindent" ><span class="paragraphHead"><a 
href="#x9-1210003" id="x9-1210003"><span 
class="ec-lmbx-10x-x-109">Conﬁguration vis</span><span 
class="ec-lmbx-10x-x-109">ée.</span><br 
class="newline" /></a></span>
   La version vulnérable d&#x2019;OpenSSL est la 0.9.8, en mode FIPS uniquement.
</p>
<!--l. 394--><p class="noindent" ><span class="paragraphHead"><a 
href="#x9-1220003" id="x9-1220003"><span 
class="ec-lmbx-10x-x-109">Fonction.</span><br 
class="newline" /></a></span>
   La fonction est accessible au chemin <span 
class="ec-lmtt-10x-x-109">openssl/crypto/dh/dh_key.c</span>. La ﬁgure <span 
class="ec-lmri-10x-x-109">Listing </span><a 
href="#x9-122001r5">2.5<!--tex4ht:ref: dhkey --></a> montre le <span 
class="ec-lmri-10x-x-109">diﬀ </span>entre
les deux versions.
</p>
   <!--l. 398-->
                                                                                                  
<pre>
−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−− dh/dh_key.c −−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
 − if (!DH_check_pub_key(dh, pub_key, &check_result) || check_result) 
 − { 
 −   DHerr(DH_F_COMPUTE_KEY,DH_R_INVALID_PUBKEY); 
 −   goto err; 
 − } 
</pre>
                                                                                                  
    <div class="caption" 
><span class="id">Listing 2.5:
    </span><span  
class="content">dh_key.c</span></div><!--tex4ht:label?: x9-122001r2 -->
<!--l. 407--><p class="indent" >   Cette partie causait un faux positif sous certaines conditions pouvant fragiliser le système.
</p>
<!--l. 409--><p class="noindent" ><span class="paragraphHead"><a 
href="#x9-1230003" id="x9-1230003"><span 
class="ec-lmbx-10x-x-109">Solution logicielle.</span><br 
class="newline" /></a></span>
   Nessus Vulnerability Scanner est un logiciel permettant de tester la conﬁguration du serveur aﬁn d&#x2019;identiﬁer
entre autres de problèmes d&#x2019;authentiﬁcation <span class="cite">[<span 
class="ec-lmbx-10x-x-109">?</span>]</span>. Le système RedHat préconise son utilisation pour savoir si cette
vulnérabilité concerne notre système.
<a 
 id="x9-123001r136"></a>
</p>
<h5 class="subsubsectionHead"><span class="titlemark">2.2.3.4   </span> <a 
href="#x9-1240004" id="x9-1240004">Conclusion</a></h5>
     Il est tout d&#x2019;abord recommandé de passer à la version OpenSSL supérieure, sinon de désactiver le mode FIPS,
ou encore de conﬁgurer la <span 
class="ec-lmri-10x-x-109">ciphersuite </span>aﬁn de ne pas permettre au serveur d&#x2019;utiliser Diﬃe Hellman comme
algorithme d&#x2019;échange de clefs.
                                                                                                  

                                                                                                  
                                                                                                  

                                                                                                  
                                                                                                  

                                                                                                  
