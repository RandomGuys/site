   <h2 class="chapterHead"><span class="titlemark">Chapitre 3</span><br /><a 
href="#x10-1250003" id="x10-1250003">Chiﬀrement et Protocoles</a></h2>
<a 
 id="x10-125001r110"></a>
<h3 class="sectionHead"><span class="titlemark">3.1   </span> <a 
href="#x10-1260001" id="x10-1260001">Déﬁnitions et contexte</a></h3>
<!--l. 5--><p class="noindent" >Nous allons tout d&#x2019;abord apporter quelques précisions au contexte dans lequel nous travaillons. Plusieurs failles ont
été trouvées sur RSA-OAEP ainsi que sur le mode CBC. Nous allons donc décrire ces deux principes et étudier
leurs vulnérabilités.<br 
class="newline" />
</p><!--l. 7--><p class="indent" >   Nous allons voir qu&#x2019;une combinaison entre un mode de chiﬀrement et un protocole de chiﬀrement peut générer
des failles, souvent graves (i.e vols de mots de passe), que le padding est également une donnée sensible et qu&#x2019;il faut
donc le choisir intelligemment, et qu&#x2019;une mauvaise documentation ou un mauvais paramétrage peuvent entraîner
des failles au niveau protocolaire.
<a 
 id="x10-126001r143"></a>
</p>
<h3 class="sectionHead"><span class="titlemark">3.2   </span> <a 
href="#x10-1270002" id="x10-1270002">Audits</a></h3>
<a 
 id="x10-127001r133"></a>
<h4 class="subsectionHead"><span class="titlemark">3.2.1   </span> <a 
href="#x10-1280001" id="x10-1280001">Audit 3.1<span class="frenchb-nbsp">&nbsp;</span>: Les &#x0022;Manger&#x2019;s attack&#x0022; sur RSA-OAEP</a></h4>
<a 
 id="x10-128001r141"></a>
<h5 class="subsubsectionHead"><span class="titlemark">3.2.1.1   </span> <a 
href="#x10-1290001" id="x10-1290001">Normes visées</a></h5>
<!--l. 13--><p class="noindent" ><span class="paragraphHead"><a 
href="#x10-1300001" id="x10-1300001"><span 
class="ec-lmbx-10x-x-109">OAEP</span><span class="frenchb-nbsp">&nbsp;</span><span 
class="ec-lmbx-10x-x-109">: </span><span 
class="ec-lmbxi-10x-x-109">Optimal Asymmetric Encryption Padding</span><span 
class="ec-lmbx-10x-x-109">. </span><br 
class="newline" /></a></span>
   Dans les chiﬀrements par blocs, cela nécessite généralement que tous les blocs soient d&#x2019;une taille précise. Or ce
n&#x2019;est pas toujours le cas. Pour cela, on rajoute des bits de bourrage (padding).<br 
class="newline" />OAEP est un schéma de remplissage, généralement utilisé avec RSA (en prétraitement). Il a été introduit en 1994
par Mihir Bellare et Phil Rogaway1. L&#x2019;OAEP est une forme de réseau de Feistel qui nécessite une source d&#x2019;aléa
ainsi que deux fonctions de hachage.<br 
class="newline" />RSA-OEAP peut être prouvé sûr dans un modèle théorique idéalisé, celui de l&#x2019;oracle aléatoire. Il est recommandé
par les PKCS.<br 
class="newline" />OAEP a deux buts<span class="frenchb-nbsp">&nbsp;</span>: </p>
      <ul class="itemize1">
      <li class="itemize">insérer un élément d&#x2019;aléatoire qui permet de passer d&#x2019;un schéma déterministe à un schéma non
      déterministe (le même message clair chiﬀré deux fois avec la même clef et le même algorithme n&#x2019;aura
      pas le même message chiﬀré.)
      </li>
      <li class="itemize">prévenir un déchiﬀrement partiel en s&#x2019;assurant que l&#x2019;attaquant ne peut retrouver une portion du text
      clair sans être capable d&#x2019;inverser la fonction trapdoor (par exemple la factorisation de deux grands
      nombres premiers<span class="frenchb-nbsp">&nbsp;</span>: il est facile de multiplier, mais quand on n&#x2019;a que le produit il est très diﬃcile de
      retrouver les facteurs).<br 
class="newline" /></li></ul>
<!--l. 22--><p class="noindent" >Il n&#x2019;est pas prouvé sûr pour une attaque IND-CCA (attaque à texte chiﬀré seulement). Victor Shoup a démontré qu&#x2019;il
n&#x2019;existe pas de preuve générale. Il a montré que dans un cas IND-CCA, quelqu&#x2019;un qui sait comme
inverser partiellement une primitive d&#x2019;insertion mais ne sait pas comment l&#x2019;inverser complètement,
                                                                                                  

                                                                                                  
pourrait bien être en mesure de casser le système. Par exemple, on peut imaginer quelqu&#x2019;un qui peut
attaquer RSAES-OAEP si on sait comment retrouver tous les octets exceptés les 20 premiers d&#x2019;un entier
généré aléatoirement chiﬀré avec RSAEP (RSA Encryption Protocole). Un tel attaquant n&#x2019;a pas besoin
d&#x2019;être capable d&#x2019;inverser entièrement RSAEP, parce qu&#x2019;il n&#x2019;utilise pas les 20 premiers octets dans son
attaque.
</p>
<!--l. 25--><p class="noindent" ><span class="paragraphHead"><a 
href="#x10-1310001" id="x10-1310001"><span 
class="ec-lmbx-10x-x-109">R</span><span 
class="ec-lmbx-10x-x-109">éseau de Feistel. </span><br 
class="newline" /></a></span>
   Il est utilisé dans les systèmes de chiﬀrement par bloc. Un schéma de Feistel repose sur des principes simples
dont des permutations, des substitutions, des échanges de blocs de données et une fonction prenant en entrée une
clé intermédiaire à chaque étage.<br 
class="newline" /></p><hr class="figure" /><div class="figure" 
>
                                                                                                  

                                                                                                  
<a 
 id="x10-131001r1"></a>
                                                                                                  

                                                                                                  

<!--l. 29--><p class="noindent" ><img 
src="audit/images/Reseau_de_feistel.png" alt="PIC"  
 />
<br /> </p><div class="caption" 
><span class="id"><span 
class="ec-lmcsc-10x-x-109">Figure</span> 3.1: </span><span  
class="content">Réseau de Feistel</span></div><!--tex4ht:label?: x10-131001r1 -->
                                                                                                  

                                                                                                  
   </div><hr class="endfigure" />
<!--l. 34--><p class="indent" >   Le chiﬀrement DES par exemple repose sur ce réseau, et eﬀectue 16 tours.<br 
class="newline" />Généralement les deux parties sont équilibrées même si par exemple des algorithmes comme MacGuﬃn de Bruce
Schneier utilisent un réseau non équilibré.
</p>
<!--l. 37--><p class="noindent" ><span class="paragraphHead"><a 
href="#x10-1320001" id="x10-1320001"><span 
class="ec-lmbx-10x-x-109">RSA-OAEP. </span><br 
class="newline" /></a></span>
   Dans la PKCS#1 est décrit le standard de RSA-OAEP. RSAES-OAEP est le terme plus facilement utilisé dans
le document<span class="frenchb-nbsp">&nbsp;</span>: RSA Encryption Scheme OAEP.<br 
class="newline" />Il regroupe les primitives RSAEP et RSADP<span class="frenchb-nbsp">&nbsp;</span>: respectivement RSA Encryption Protocole et RSA Decryption
Protocole.
</p>
<!--l. 41--><p class="noindent" ><span class="paragraphHead"><a 
href="#x10-1330001" id="x10-1330001"><span 
class="ec-lmbx-10x-x-109">RSAES-OAEP-ENCRYPT. </span><br 
class="newline" /></a></span>
   Options<span class="frenchb-nbsp">&nbsp;</span>:
      </p><dl class="description"><dt class="description">
<span 
class="ec-lmbx-10x-x-109">Hash</span><span class="frenchb-nbsp">&nbsp;</span><span 
class="ec-lmbx-10x-x-109">:</span> </dt><dd 
class="description">fonction de hachage (<span 
class="ec-lmtt-10x-x-109">hLen </span>contient la longueur en octets de la sortie de fonction de hachage)<span class="frenchb-thinspace">&nbsp;</span>;
      </dd><dt class="description">
<span 
class="ec-lmbx-10x-x-109">MGF</span><span class="frenchb-nbsp">&nbsp;</span><span 
class="ec-lmbx-10x-x-109">:</span> </dt><dd 
class="description">fonction de génération de masque.<br 
class="newline" /></dd></dl>
<!--l. 47--><p class="noindent" >Entrée<span class="frenchb-nbsp">&nbsp;</span>:
      </p><dl class="description"><dt class="description">
<span 
class="ec-lmbx-10x-x-109">(n, e)</span><span class="frenchb-nbsp">&nbsp;</span><span 
class="ec-lmbx-10x-x-109">:</span>  </dt><dd 
class="description">destinataire de la clef publique RSA (<span 
class="ec-lmtt-10x-x-109">k </span>contient la longueur en octets du modulo RSA <span 
class="ec-lmtt-10x-x-109">n</span>)<span class="frenchb-thinspace">&nbsp;</span>;
      </dd><dt class="description">
<span 
class="ec-lmbx-10x-x-109">M</span><span class="frenchb-nbsp">&nbsp;</span><span 
class="ec-lmbx-10x-x-109">:</span>  </dt><dd 
class="description">message à chiﬀrer, une chaîne d&#x2019;octets de longueur <span 
class="ec-lmtt-10x-x-109">mLen</span>, quand <span 
class="ec-lmtt-10x-x-109">mLen &#x003C;= k - 2hLen - 2</span><span class="frenchb-thinspace">&nbsp;</span>;
      </dd><dt class="description">
<span 
class="ec-lmbx-10x-x-109">L</span><span class="frenchb-nbsp">&nbsp;</span><span 
class="ec-lmbx-10x-x-109">:</span>  </dt><dd 
class="description">champ optionnel à associer au message, la valeur par défaut pour <span 
class="ec-lmtt-10x-x-109">L</span>, si <span 
class="ec-lmtt-10x-x-109">L </span>n&#x2019;a aucune condition, est la
      chaîne vide.<br 
class="newline" /></dd></dl>
<!--l. 53--><p class="noindent" >Sortie<span class="frenchb-nbsp">&nbsp;</span>:
      </p><dl class="description"><dt class="description">
<span 
class="ec-lmbx-10x-x-109">C</span><span class="frenchb-nbsp">&nbsp;</span><span 
class="ec-lmbx-10x-x-109">:</span>  </dt><dd 
class="description">texte chiﬀré, une chaîne d&#x2019;octets de longueur <span 
class="ec-lmtt-10x-x-109">k</span>.<br 
class="newline" /></dd></dl>
<!--l. 57--><p class="noindent" >Erreurs<span class="frenchb-nbsp">&nbsp;</span>: </p>
      <ul class="itemize1">
      <li class="itemize">&#x0022;<span 
class="ec-lmri-10x-x-109">message too long</span>&#x0022;<span class="frenchb-thinspace">&nbsp;</span>;
      </li>
      <li class="itemize">&#x0022;<span 
class="ec-lmri-10x-x-109">label too long</span>&#x0022;.<br 
class="newline" /></li></ul>
<!--l. 62--><p class="noindent" >Précondition<span class="frenchb-nbsp">&nbsp;</span>: </p>
                                                                                                  

                                                                                                  
      <ul class="itemize1">
      <li class="itemize">la clef publique RSA <span 
class="ec-lmtt-10x-x-109">(n, e) </span>est valide.<br 
class="newline" /></li></ul>
<!--l. 66--><p class="noindent" >Étapes<span class="frenchb-nbsp">&nbsp;</span>:
      </p><ol  class="enumerate1" >
      <li 
  class="enumerate" id="x10-133002x1">vériﬁer de la longueur<span class="frenchb-nbsp">&nbsp;</span>:
         <ol  class="enumerate2" >
         <li 
  class="enumerate" id="x10-133004x1">si la longueur de <span 
class="ec-lmtt-10x-x-109">L </span>est plus grande que la longueur limite en entrée de la fonction de hachage
         (<span 
class="rm-lmr-10x-x-109">2</span><sup><span 
class="rm-lmr-8">61</span></sup> <span 
class="lmsy-10x-x-109">− </span><span 
class="rm-lmr-10x-x-109">1 </span>octets pour SHA-1), renvoyer &#x0022;<span 
class="ec-lmri-10x-x-109">label too long</span>&#x0022; et arrêter<span class="frenchb-thinspace">&nbsp;</span>;
         </li>
         <li 
  class="enumerate" id="x10-133006x2">si <span 
class="ec-lmtt-10x-x-109">mLen &#x003E; k - 2hLen - 2</span>, le message &#x0022;<span 
class="ec-lmri-10x-x-109">message too long</span>&#x0022; est renvoyé et la fonction est stoppée.<br 
class="newline" /></li></ol>
      </li>
      <li 
  class="enumerate" id="x10-133008x2">coder EME-OAEP<span class="frenchb-nbsp">&nbsp;</span>:
         <ol  class="enumerate2" >
         <li 
  class="enumerate" id="x10-133010x1">si l&#x2019;étiquette <span 
class="ec-lmtt-10x-x-109">L </span>n&#x2019;est pas spéciﬁée, laisser <span 
class="ec-lmtt-10x-x-109">L </span>à une chaîne vide. Laisser <span 
class="ec-lmtt-10x-x-109">lHash = Hash(L)</span>, une
         chaîne d&#x2019;octets de taille <span 
class="ec-lmtt-10x-x-109">hLen</span><span class="frenchb-thinspace">&nbsp;</span>;
         </li>
         <li 
  class="enumerate" id="x10-133012x2">générer une chaîne d&#x2019;octets PS consistant en <span 
class="ec-lmtt-10x-x-109">k - mLen - 2hLen - 2 </span>d&#x2019;octets zéro. La taille de
         <span 
class="ec-lmtt-10x-x-109">PS </span>peut être zéro<span class="frenchb-thinspace">&nbsp;</span>;
         </li>
         <li 
  class="enumerate" id="x10-133014x3">concaténer <span 
class="ec-lmtt-10x-x-109">lHash</span>, <span 
class="ec-lmtt-10x-x-109">PS</span>, un unique octet avec la valeur hexadécimale <span 
class="ec-lmri-10x-x-109">0x01</span>, et le message <span 
class="ec-lmtt-10x-x-109">M </span>pour
         former un bloc de données DB de longueur <span 
class="ec-lmtt-10x-x-109">k - hLen - 1 </span>octets, tel que<span class="frenchb-nbsp">&nbsp;</span>: <span 
class="ec-lmtt-10x-x-109">DB </span>= <span 
class="ec-lmtt-10x-x-109">lHash </span>||<span 
class="ec-lmtt-10x-x-109">PS </span>||<span 
class="ec-lmri-10x-x-109">0x01</span>
         ||<span 
class="ec-lmtt-10x-x-109">M</span><span class="frenchb-thinspace">&nbsp;</span>;
         </li>
         <li 
  class="enumerate" id="x10-133016x4">générer un une chaîne d&#x2019;octets aléatoires de longueur <span 
class="ec-lmtt-10x-x-109">hLen</span><span class="frenchb-thinspace">&nbsp;</span>;
         </li>
         <li 
  class="enumerate" id="x10-133018x5">laisser <span 
class="ec-lmtt-10x-x-109">dbMask = MGF(seed, k - hLen - 1)</span><span class="frenchb-thinspace">&nbsp;</span>;
         </li>
         <li 
  class="enumerate" id="x10-133020x6">laisser <span 
class="ec-lmtt-10x-x-109">maskedDB = DB xor dbMask</span><span class="frenchb-thinspace">&nbsp;</span>;
         </li>
         <li 
  class="enumerate" id="x10-133022x7">laisser <span 
class="ec-lmtt-10x-x-109">seedMask = MGF(maskedDB, hLen)</span><span class="frenchb-thinspace">&nbsp;</span>;
         </li>
         <li 
  class="enumerate" id="x10-133024x8">laisser <span 
class="ec-lmtt-10x-x-109">maskedSeed = seed xor seedMask</span><span class="frenchb-thinspace">&nbsp;</span>;
         </li>
         <li 
  class="enumerate" id="x10-133026x9">concaténer un unique octet avec la valeur hexadécimale <span 
class="ec-lmri-10x-x-109">0x00</span>, <span 
class="ec-lmtt-10x-x-109">maskedSeed</span>, et <span 
class="ec-lmtt-10x-x-109">maskedDB </span>pour
         former un message chiﬀré <span 
class="ec-lmtt-10x-x-109">EM </span>de longueur <span 
class="ec-lmtt-10x-x-109">k </span>octets tel que <span 
class="ec-lmtt-10x-x-109">EM = 0x00 </span>||<span 
class="ec-lmtt-10x-x-109">maskedSeed </span>||<span 
class="ec-lmtt-10x-x-109">maskedDB</span>.<br 
class="newline" /></li></ol>
      </li>
      <li 
  class="enumerate" id="x10-133028x3">chiﬀrement RSA<span class="frenchb-nbsp">&nbsp;</span>:
         <ol  class="enumerate2" >
         <li 
  class="enumerate" id="x10-133030x1">convertir le message codé <span 
class="ec-lmtt-10x-x-109">EM </span>en un entier représentatif du message <span 
class="ec-lmtt-10x-x-109">m</span><span class="frenchb-nbsp">&nbsp;</span>: <span 
class="ec-lmtt-10x-x-109">m = OS2IP (EM)</span><span class="frenchb-thinspace">&nbsp;</span>;
                                                                                                  

                                                                                                  
         </li>
         <li 
  class="enumerate" id="x10-133032x2">appliquer la primitive de chiﬀrement <span 
class="ec-lmtt-10x-x-109">RSAEP </span>avec la clef RSA publique (n, e) pour produire un
         entier c représentatif du message chiﬀré<span class="frenchb-nbsp">&nbsp;</span>: <span 
class="ec-lmtt-10x-x-109">c = RSAEP ((n, e), m)</span><span class="frenchb-thinspace">&nbsp;</span>;
         </li>
         <li 
  class="enumerate" id="x10-133034x3">convertir le texte chiﬀré représentatif <span 
class="ec-lmtt-10x-x-109">c </span>en un texte chiﬀré <span 
class="ec-lmtt-10x-x-109">C </span>de taille <span 
class="ec-lmtt-10x-x-109">k </span>octets<span class="frenchb-nbsp">&nbsp;</span>: <span 
class="ec-lmtt-10x-x-109">C = I2OSP (c,</span>
         <span 
class="ec-lmtt-10x-x-109">k)</span>.<br 
class="newline" /></li></ol>
      </li>
      <li 
  class="enumerate" id="x10-133036x4">envoyer en sortie le texte chiﬀré <span 
class="ec-lmtt-10x-x-109">C</span>.<br 
class="newline" /></li></ol>
<!--l. 93--><p class="noindent" ><span class="paragraphHead"><a 
href="#x10-1340001" id="x10-1340001"><span 
class="ec-lmbx-10x-x-109">Note.</span><br 
class="newline" /></a></span>
   Si <span 
class="ec-lmtt-10x-x-109">L </span>est une chaîne vide, la valeur du hash correspondante <span 
class="ec-lmtt-10x-x-109">lHash </span>a la représentation hexadécimale suivante
pour diﬀérents choix de hash<span class="frenchb-nbsp">&nbsp;</span>:
</p>
   <div class="table">
                                                                                                  

                                                                                                  
<!--l. 97--><p class="indent" >   <a 
 id="x10-134001r1"></a></p><hr class="float" /><div class="float" 
>
                                                                                                  

                                                                                                  
 <table id="TBL-5" class="tabular table table-striped" 
cellspacing="0" cellpadding="0"  
><colgroup id="TBL-5-1g"><col 
id="TBL-5-1" /><col 
id="TBL-5-2" /><col 
id="TBL-5-3" /><col 
id="TBL-5-4" /><col 
id="TBL-5-5" /><col 
id="TBL-5-6" /><col 
id="TBL-5-7" /></colgroup><tr  
 style="vertical-align:baseline;" id="TBL-5-1-"><td  style="white-space:wrap; text-align:left;" id="TBL-5-1-1"  
class="td11"> <!--l. 108--><p class="noindent" >SHA-1<span class="frenchb-nbsp">&nbsp;</span>: </p> </td><td  style="white-space:nowrap; text-align:left;" id="TBL-5-1-2"  
class="td11"> (0x)da39a3ee  </td><td  style="white-space:nowrap; text-align:left;" id="TBL-5-1-3"  
class="td11"> 5e6b4b0d  </td><td  style="white-space:nowrap; text-align:left;" id="TBL-5-1-4"  
class="td11"> 3255bfef   </td><td  style="white-space:nowrap; text-align:left;" id="TBL-5-1-5"  
class="td11"> 95601890  </td><td  style="white-space:nowrap; text-align:left;" id="TBL-5-1-6"  
class="td11"> afd80709  </td><td  style="white-space:nowrap; text-align:left;" id="TBL-5-1-7"  
class="td11">          </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-5-2-"><td  style="white-space:wrap; text-align:left;" id="TBL-5-2-1"  
class="td11"> <!--l. 108--><p class="noindent" >SHA-256<span class="frenchb-nbsp">&nbsp;</span>: </p> </td><td  style="white-space:nowrap; text-align:left;" id="TBL-5-2-2"  
class="td11"> (0x)e3b0c442  </td><td  style="white-space:nowrap; text-align:left;" id="TBL-5-2-3"  
class="td11"> 98fc1c14   </td><td  style="white-space:nowrap; text-align:left;" id="TBL-5-2-4"  
class="td11"> 9afbf4c8   </td><td  style="white-space:nowrap; text-align:left;" id="TBL-5-2-5"  
class="td11"> 996fb924  </td><td  style="white-space:nowrap; text-align:left;" id="TBL-5-2-6"  
class="td11"> 27ae41e4  </td><td  style="white-space:nowrap; text-align:left;" id="TBL-5-2-7"  
class="td11"> 649b934c  </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-5-3-"><td  style="white-space:wrap; text-align:left;" id="TBL-5-3-1"  
class="td11"> <!--l. 108--><p class="noindent" >    </p></td><td  style="white-space:nowrap; text-align:left;" id="TBL-5-3-2"  
class="td11"> a495991b       </td><td  style="white-space:nowrap; text-align:left;" id="TBL-5-3-3"  
class="td11"> 7852b855  </td><td  style="white-space:nowrap; text-align:left;" id="TBL-5-3-4"  
class="td11">          </td><td  style="white-space:nowrap; text-align:left;" id="TBL-5-3-5"  
class="td11">          </td><td  style="white-space:nowrap; text-align:left;" id="TBL-5-3-6"  
class="td11">          </td><td  style="white-space:nowrap; text-align:left;" id="TBL-5-3-7"  
class="td11">          </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-5-4-"><td  style="white-space:wrap; text-align:left;" id="TBL-5-4-1"  
class="td11"> <!--l. 108--><p class="noindent" >SHA-384<span class="frenchb-nbsp">&nbsp;</span>: </p> </td><td  style="white-space:nowrap; text-align:left;" id="TBL-5-4-2"  
class="td11"> (0x)38b060a7  </td><td  style="white-space:nowrap; text-align:left;" id="TBL-5-4-3"  
class="td11"> 51ac9638  </td><td  style="white-space:nowrap; text-align:left;" id="TBL-5-4-4"  
class="td11"> 4cd9327e  </td><td  style="white-space:nowrap; text-align:left;" id="TBL-5-4-5"  
class="td11"> b1b1e36a  </td><td  style="white-space:nowrap; text-align:left;" id="TBL-5-4-6"  
class="td11"> 21fdb711  </td><td  style="white-space:nowrap; text-align:left;" id="TBL-5-4-7"  
class="td11"> 14be0743  </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-5-5-"><td  style="white-space:wrap; text-align:left;" id="TBL-5-5-1"  
class="td11"> <!--l. 108--><p class="noindent" >    </p></td><td  style="white-space:nowrap; text-align:left;" id="TBL-5-5-2"  
class="td11"> 4c0cc7bf        </td><td  style="white-space:nowrap; text-align:left;" id="TBL-5-5-3"  
class="td11"> 63f6e1da   </td><td  style="white-space:nowrap; text-align:left;" id="TBL-5-5-4"  
class="td11"> 274edebf  </td><td  style="white-space:nowrap; text-align:left;" id="TBL-5-5-5"  
class="td11"> e76f65fb   </td><td  style="white-space:nowrap; text-align:left;" id="TBL-5-5-6"  
class="td11"> d51ad2f1  </td><td  style="white-space:nowrap; text-align:left;" id="TBL-5-5-7"  
class="td11"> 4898b95b  </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-5-6-"><td  style="white-space:wrap; text-align:left;" id="TBL-5-6-1"  
class="td11"> <!--l. 108--><p class="noindent" >SHA-512<span class="frenchb-nbsp">&nbsp;</span>: </p> </td><td  style="white-space:nowrap; text-align:left;" id="TBL-5-6-2"  
class="td11"> (0x)cf83e135   </td><td  style="white-space:nowrap; text-align:left;" id="TBL-5-6-3"  
class="td11"> 7eefb8bd  </td><td  style="white-space:nowrap; text-align:left;" id="TBL-5-6-4"  
class="td11"> f1542850  </td><td  style="white-space:nowrap; text-align:left;" id="TBL-5-6-5"  
class="td11"> d66d8007  </td><td  style="white-space:nowrap; text-align:left;" id="TBL-5-6-6"  
class="td11"> d620e405  </td><td  style="white-space:nowrap; text-align:left;" id="TBL-5-6-7"  
class="td11"> 0b5715dc  </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-5-7-"><td  style="white-space:wrap; text-align:left;" id="TBL-5-7-1"  
class="td11"> <!--l. 108--><p class="noindent" >    </p></td><td  style="white-space:nowrap; text-align:left;" id="TBL-5-7-2"  
class="td11"> 83f4a921        </td><td  style="white-space:nowrap; text-align:left;" id="TBL-5-7-3"  
class="td11"> d36ce9ce  </td><td  style="white-space:nowrap; text-align:left;" id="TBL-5-7-4"  
class="td11"> 47d0d13c  </td><td  style="white-space:nowrap; text-align:left;" id="TBL-5-7-5"  
class="td11"> 5d85f2b0  </td><td  style="white-space:nowrap; text-align:left;" id="TBL-5-7-6"  
class="td11"> ﬀ8318d2   </td><td  style="white-space:nowrap; text-align:left;" id="TBL-5-7-7"  
class="td11"> 877eec2f   </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-5-8-"><td  style="white-space:wrap; text-align:left;" id="TBL-5-8-1"  
class="td11"> <!--l. 108--><p class="noindent" >    </p></td><td  style="white-space:nowrap; text-align:left;" id="TBL-5-8-2"  
class="td11"> 63b931bd       </td><td  style="white-space:nowrap; text-align:left;" id="TBL-5-8-3"  
class="td11"> 47417a81  </td><td  style="white-space:nowrap; text-align:left;" id="TBL-5-8-4"  
class="td11"> a538327a  </td><td  style="white-space:nowrap; text-align:left;" id="TBL-5-8-5"  
class="td11"> f927da3e   </td><td  style="white-space:nowrap; text-align:left;" id="TBL-5-8-6"  
class="td11">          </td><td  style="white-space:nowrap; text-align:left;" id="TBL-5-8-7"  
class="td11">          </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-5-9-"><td  style="white-space:wrap; text-align:left;" id="TBL-5-9-1"  
class="td11"> <!--l. 108--><p class="noindent" >    </p></td></tr></table>
 <div class="caption" 
><span class="id"><span 
class="ec-lmcsc-10x-x-109">Table</span> 3.1: </span><span  
class="content">Représentations hexadécimales</span></div><!--tex4ht:label?: x10-134001r1 -->
                                                                                                  

                                                                                                  
   </div><hr class="endfloat" />
   </div>
   <hr class="figure" /><div class="figure" 
>
                                                                                                  

                                                                                                  
<a 
 id="x10-134002r2"></a><a 
 id="x10-142001r14"></a>
                                                                                                  

                                                                                                  
<div class="center" 
>
<!--l. 115--><p class="noindent" >
</p><!--l. 162--><p class="noindent" >                                                        </p><!--l. 155--><p class="noindent" >         </p><!--l. 159--><p class="noindent" >lHashPSMDB =<span 
class="ec-lmtt-10x-x-109">xor</span>MGFseed<span 
class="ec-lmtt-10x-x-109">xor</span>00MGF00EM=maskedSeedmaskedDB
</p></div>
<br /> <div class="caption" 
><span class="id"><span 
class="ec-lmcsc-10x-x-109">Figure</span> 3.2: </span><span  
class="content">Opération de chiﬀrement EME-OAEP</span></div><!--tex4ht:label?: x10-134002r2 -->
                                                                                                  

                                                                                                  
   </div><hr class="endfigure" />
<!--l. 168--><p class="indent" >   <span 
class="ec-lmtt-10x-x-109">lHash </span>est le hash de l&#x2019;étiquette optionnelle <span 
class="ec-lmtt-10x-x-109">L</span>. L&#x2019;opération de déchiﬀrement suivant inverse les étapes pour
retrouver <span 
class="ec-lmtt-10x-x-109">M </span>et vériﬁer <span 
class="ec-lmtt-10x-x-109">lHash </span>et <span 
class="ec-lmtt-10x-x-109">PS</span>.
</p>
<!--l. 171--><p class="noindent" ><span class="paragraphHead"><a 
href="#x10-1350001" id="x10-1350001"><span 
class="ec-lmbx-10x-x-109">RSAES-OAEP-DECRYPT (K, C, L). </span><br 
class="newline" /></a></span>
   Options<span class="frenchb-nbsp">&nbsp;</span>:
      </p><dl class="description"><dt class="description">
<span 
class="ec-lmbx-10x-x-109">Hash</span><span class="frenchb-nbsp">&nbsp;</span><span 
class="ec-lmbx-10x-x-109">:</span> </dt><dd 
class="description">fonction de hachage (<span 
class="ec-lmtt-10x-x-109">hLen </span>contient la longueur en octets de la sortie de la fonction de hachage)<span class="frenchb-thinspace">&nbsp;</span>;
      </dd><dt class="description">
<span 
class="ec-lmbx-10x-x-109">MGF</span><span class="frenchb-nbsp">&nbsp;</span><span 
class="ec-lmbx-10x-x-109">:</span> </dt><dd 
class="description">fonction de génération du masque.<br 
class="newline" /></dd></dl>
<!--l. 178--><p class="noindent" >Entrée<span class="frenchb-nbsp">&nbsp;</span>:
      </p><dl class="description"><dt class="description">
<span 
class="ec-lmbx-10x-x-109">K</span><span class="frenchb-nbsp">&nbsp;</span><span 
class="ec-lmbx-10x-x-109">:</span> </dt><dd 
class="description">destinataire de la clef privée RSA (<span 
class="ec-lmtt-10x-x-109">k </span>contient la longueur en octets du modulo RSA <span 
class="ec-lmtt-10x-x-109">n</span>)<span class="frenchb-thinspace">&nbsp;</span>;
      </dd><dt class="description">
<span 
class="ec-lmbx-10x-x-109">C</span><span class="frenchb-nbsp">&nbsp;</span><span 
class="ec-lmbx-10x-x-109">:</span> </dt><dd 
class="description">texte chiﬀré à déchiﬀrer, une chaîne de caractères de taille <span 
class="ec-lmtt-10x-x-109">k</span>, où <span 
class="ec-lmtt-10x-x-109">k = 2hLen + 2</span><span class="frenchb-thinspace">&nbsp;</span>;
      </dd><dt class="description">
<span 
class="ec-lmbx-10x-x-109">L</span><span class="frenchb-nbsp">&nbsp;</span><span 
class="ec-lmbx-10x-x-109">:</span> </dt><dd 
class="description">champ optionnel dont l&#x2019;association avec le message doit être garantie<span class="frenchb-thinspace">&nbsp;</span>; la valeur par défaut pour <span 
class="ec-lmtt-10x-x-109">L </span>est, si
      pas de spéciﬁcation, une chaîne vide.<br 
class="newline" /></dd></dl>
<!--l. 184--><p class="noindent" >Sortie<span class="frenchb-nbsp">&nbsp;</span>:
      </p><dl class="description"><dt class="description">
<span 
class="ec-lmbx-10x-x-109">M</span><span class="frenchb-nbsp">&nbsp;</span><span 
class="ec-lmbx-10x-x-109">:</span> </dt><dd 
class="description">message, une chaîne d&#x2019;octets de longueur <span 
class="ec-lmtt-10x-x-109">mLen</span>, où <span 
class="ec-lmtt-10x-x-109">mLen &#x003C;= k - 2hLen - 2</span>.<br 
class="newline" /></dd></dl>
<!--l. 188--><p class="noindent" >Erreur<span class="frenchb-nbsp">&nbsp;</span>: </p>
      <ul class="itemize1">
      <li class="itemize">&#x0022;decryption error&#x0022;<span class="frenchb-thinspace">&nbsp;</span>;</li></ul>
<!--l. 192--><p class="noindent" >Étapes<span class="frenchb-nbsp">&nbsp;</span>:
      </p><ol  class="enumerate1" >
      <li 
  class="enumerate" id="x10-135002x1">Vériﬁcation des longueurs<span class="frenchb-nbsp">&nbsp;</span>:
         <ol  class="enumerate2" >
         <li 
  class="enumerate" id="x10-135004x1">Si la longueur de <span 
class="ec-lmtt-10x-x-109">L </span>est supérieure à la taille limite en entrée de la fonction de hachage (<span 
class="rm-lmr-10x-x-109">2</span><sup><span 
class="rm-lmr-8">61</span><span 
class="lmsy8-">−</span><span 
class="rm-lmr-8">1</span></sup>
         octets pour SHA-1), renvoie &#x0022;decryption error&#x0022; et s&#x2019;arrête<span class="frenchb-thinspace">&nbsp;</span>;
         </li>
         <li 
  class="enumerate" id="x10-135006x2">Si la longueur du texte chiﬀré <span 
class="ec-lmtt-10x-x-109">C </span>n&#x2019;est pas de <span 
class="ec-lmtt-10x-x-109">k </span>octets, renvoie &#x0022;decryption error&#x0022; et s&#x2019;arrête<span class="frenchb-thinspace">&nbsp;</span>;
         </li>
         <li 
  class="enumerate" id="x10-135008x3">Si <span 
class="ec-lmtt-10x-x-109">k &#x003C; 2hLen + 2</span>, renvoie &#x0022;decryption error&#x0022; et s&#x2019;arrête.<br 
class="newline" /></li></ol>
      </li>
      <li 
  class="enumerate" id="x10-135010x2">déchiﬀrement RSA<span class="frenchb-nbsp">&nbsp;</span>:
                                                                                                  

                                                                                                  
         <ol  class="enumerate2" >
         <li 
  class="enumerate" id="x10-135012x1">Convertir le texte chiﬀré <span 
class="ec-lmtt-10x-x-109">C </span>en un entier <span 
class="ec-lmtt-10x-x-109">c </span>représentatif du message chiﬀré<span class="frenchb-nbsp">&nbsp;</span>: <span 
class="ec-lmtt-10x-x-109">c = OS2IP (C)</span><span class="frenchb-thinspace">&nbsp;</span>;
         </li>
         <li 
  class="enumerate" id="x10-135014x2">Appliquer la primitive de déchiﬀrement <span 
class="ec-lmtt-10x-x-109">RSADP </span>à la clef privée RSA <span 
class="ec-lmtt-10x-x-109">K </span>et au message chiﬀré
         représentatif <span 
class="ec-lmtt-10x-x-109">c </span>pour produire un entier <span 
class="ec-lmtt-10x-x-109">m </span>représentatif du message clair<span class="frenchb-nbsp">&nbsp;</span>: <span 
class="ec-lmtt-10x-x-109">m = RSADP (K, c)</span><span class="frenchb-thinspace">&nbsp;</span>;<br 
class="newline" />si  RSADP  renvoie  &#x0022;ciphertext  representative  out  of  range&#x0022;  (signiﬁe  que  <span 
class="ec-lmtt-10x-x-109">c &#x003E;= n</span>),  renvoie
         &#x0022;decryption error&#x0022; et s&#x2019;arrête<span class="frenchb-thinspace">&nbsp;</span>;
         </li>
         <li 
  class="enumerate" id="x10-135016x3">convertir le message représentatif <span 
class="ec-lmtt-10x-x-109">m </span>en un message déchiﬀré <span 
class="ec-lmtt-10x-x-109">EM </span>de longueur <span 
class="ec-lmtt-10x-x-109">k </span>octets<span class="frenchb-nbsp">&nbsp;</span>: <span 
class="ec-lmtt-10x-x-109">EM = I2OSP</span>
         <span 
class="ec-lmtt-10x-x-109">(m, k)</span>.<br 
class="newline" /></li></ol>
      </li>
      <li 
  class="enumerate" id="x10-135018x3">déchiﬀrement EME-OAEP<span class="frenchb-nbsp">&nbsp;</span>:
         <ol  class="enumerate2" >
         <li 
  class="enumerate" id="x10-135020x1">si l&#x2019;étiquette <span 
class="ec-lmtt-10x-x-109">L </span>n&#x2019;est pas spéciﬁée, laisser <span 
class="ec-lmtt-10x-x-109">L </span>à une chaîne vide, laisser <span 
class="ec-lmtt-10x-x-109">lHash = Hash(L)</span>, une
         chaîne d&#x2019;octets de longueur <span 
class="ec-lmtt-10x-x-109">hLen</span>
         </li>
         <li 
  class="enumerate" id="x10-135022x2">séparer  le  message  encodé  <span 
class="ec-lmtt-10x-x-109">EM </span>dans  un  seul  octet  <span 
class="ec-lmtt-10x-x-109">Y</span>,  une  chaîne  d&#x2019;octets  <span 
class="ec-lmtt-10x-x-109">maskedSeed </span>de
         longueur <span 
class="ec-lmtt-10x-x-109">hLen</span>, et une chaîne d&#x2019;octets <span 
class="ec-lmtt-10x-x-109">maskedDB </span>de longueur <span 
class="ec-lmtt-10x-x-109">k - hLen - 1 </span>telle que <span 
class="ec-lmtt-10x-x-109">EM = Y</span>
         <span 
class="ec-lmtt-10x-x-109">||maskedSeed ||maskedDB</span><span class="frenchb-thinspace">&nbsp;</span>;
         </li>
         <li 
  class="enumerate" id="x10-135024x3">laisser <span 
class="ec-lmtt-10x-x-109">seedMask = MGF(maskedDB, hLen)</span><span class="frenchb-thinspace">&nbsp;</span>;
         </li>
         <li 
  class="enumerate" id="x10-135026x4">laisser <span 
class="ec-lmtt-10x-x-109">seed = maskedSeed xor seedMask</span><span class="frenchb-thinspace">&nbsp;</span>;
         </li>
         <li 
  class="enumerate" id="x10-135028x5">laisser <span 
class="ec-lmtt-10x-x-109">dbMask = MGF(seed, k - hLen - 1)</span><span class="frenchb-thinspace">&nbsp;</span>;
         </li>
         <li 
  class="enumerate" id="x10-135030x6">laisser <span 
class="ec-lmtt-10x-x-109">DB = maskedDB xor dbMask</span><span class="frenchb-thinspace">&nbsp;</span>;
         </li>
         <li 
  class="enumerate" id="x10-135032x7">séparer <span 
class="ec-lmtt-10x-x-109">DB </span>en une chaîne d&#x2019;octet <span 
class="ec-lmtt-10x-x-109">lHash </span>de longueur <span 
class="ec-lmtt-10x-x-109">hLen</span>, une chaîne de padding (possiblement
         vide) <span 
class="ec-lmtt-10x-x-109">PS </span>consistant en des octets hexadécimaux de valeur <span 
class="ec-lmri-10x-x-109">0x00</span>, et un message <span 
class="ec-lmtt-10x-x-109">M </span>tel que <span 
class="ec-lmtt-10x-x-109">DB =</span>
         <span 
class="ec-lmtt-10x-x-109">lHash ||PS ||0x01 ||M</span><span class="frenchb-thinspace">&nbsp;</span>; <br 
class="newline" />s&#x2019;il n&#x2019;y a pas d&#x2019;octet avec la valeur hexadécimale <span 
class="ec-lmri-10x-x-109">0x01 </span>pour séparer <span 
class="ec-lmtt-10x-x-109">PS </span>de <span 
class="ec-lmtt-10x-x-109">M</span>, si <span 
class="ec-lmtt-10x-x-109">lHash </span>n&#x2019;est pas
         égal à <span 
class="ec-lmtt-10x-x-109">lHash</span>, ou si <span 
class="ec-lmtt-10x-x-109">Y </span>n&#x2019;est pas une sortie non nulle, renvoyer &#x0022;decryption error&#x0022; et s&#x2019;arrêter.<br 
class="newline" /></li></ol>
      </li>
      <li 
  class="enumerate" id="x10-135034x4">renvoyer le message M.<br 
class="newline" /></li></ol>
<!--l. 220--><p class="noindent" ><span class="paragraphHead"><a 
href="#x10-1360001" id="x10-1360001"><span 
class="ec-lmbx-10x-x-109">Note. </span><br 
class="newline" /></a></span>
                                                                                                  

                                                                                                  
   Il faut faire attention qu&#x2019;un adversaire ne puisse distinguer les diﬀérentes erreurs dans les conditions de l&#x2019;étape
3, que ce soit par un message d&#x2019;erreur, ou un temps de réponse diﬀérent, ou, plus généralement, apprendre une
information partielle à propos du message en clair <span 
class="ec-lmtt-10x-x-109">EM</span>. Sinon un adversaire peut être en mesure d&#x2019;obtenir des
informations utiles sur le déchiﬀrement du texte chiﬀré <span 
class="ec-lmtt-10x-x-109">C</span>, conduisant à une attaque à chiﬀré choisi telle que celle
observée par Manger.
</p>
<!--l. 223--><p class="noindent" ><span class="paragraphHead"><a 
href="#x10-1370001" id="x10-1370001"><span 
class="ec-lmbx-10x-x-109">RSAES-PKCS1-v1_ 5. </span><br 
class="newline" /></a></span>
   RSAES-PKCS1-v1_5 combine les primitives RSAEP et RSADP avec la méthode de codage EME-PKCS1-v1_
5. Il est mathématiquement équivalent au schéma de chiﬀrement dans la PKCS # 1 v1.5. RSAES-PKCS1-v1_ 5
peut fonctionner sur des messages de longueur supérieure à <span 
class="ec-lmtt-10x-x-109">k - 11 </span>octets (<span 
class="ec-lmtt-10x-x-109">k </span>est la longueur en octets du modulo
RSA), bien qu&#x2019;il faille faire attention aux attaques portant sur les faibles exposants RSA menée par Coppersmith,
Franklin, Patarin, and Reiter quand les longs messages sont chiﬀrés.<br 
class="newline" />En règle générale, l&#x2019;utilisation de ce schéma pour chiﬀrer un message arbitraire, en opposition à une clef générée
aléatoirement, n&#x2019;est pas recommandée.<br 
class="newline" />Il est possible de générer des textes chiﬀrés RSAES-PKCS1-v1_5 valides sans connaître les messages clairs
correspondants, avec une probabilité raisonnable de réussite.<br 
class="newline" />Cette possibilité peut être exploitée dans une attaque à chiﬀré choisi. Par conséquent, si RSAES-PKCS1-v1_5 doit
être utilisé, certaines contre mesures faciles à implémenter devraient être mises en place aﬁn de contrecarrer
l&#x2019;attaque trouvée.<br 
class="newline" />Des exemples typiques comprennent l&#x2019;ajout de la structure des données à encoder, le contrôle rigoureux de la
conformité des PKCS# 1v1.5 (et d&#x2019;autres redondances) dans les messages déchiﬀrés, et la consolidation
des messages d&#x2019;erreur dans un protocole client-serveur basé sur PKCS # 1 v1.5. Ils peuvent tous
être des contre-mesures eﬃcaces et n&#x2019;entraînent pas de changement à un protocole n˚ 1 sur la base
de v1.5-PKCS. Il a été récemment montré que la sécurité du protocole SSL / TLS handshake, qui
utilise RSAES-PKCS1-v1_5 et certaines contre-mesures, peut être liée à une variante du problème
RSA.<br 
class="newline" />
</p>
<!--l. 231--><p class="noindent" ><span class="paragraphHead"><a 
href="#x10-1380001" id="x10-1380001"><span 
class="ec-lmbx-10x-x-109">Note. </span><br 
class="newline" /></a></span>
   Les passages suivants décrivent des recommandations concernant l&#x2019;utilisation de RSAES-PKCS1-v1_5. Les
recommandations de la version 1.5 de ce document sont incluses ainsi que de nouvelles recommandations motivées
par les avancées de cryptanalyses durant les années suivantes. </p>
      <ul class="itemize1">
      <li class="itemize">il est recommandé que les octets pseudo-aléatoires soient générés indépendamment pour chaque
      processus de chiﬀrement, en particulier si la même donnée est en entrée pour plus d&#x2019;un processus de
      chiﬀrement. Les résultats de Haastad sont une des motivations pour cette recommandation<span class="frenchb-thinspace">&nbsp;</span>;
      </li>
      <li class="itemize">la chaîne de padding <span 
class="ec-lmtt-10x-x-109">PS </span>est d&#x2019;une longueur d&#x2019;au moins 8 octets, ce qui est une condition de sécurité
      pour les opérations sur les clefs publiques, et qui rend diﬃcile pour les attaquants de récupérer les
                                                                                                  

                                                                                                  
      données en essayant tous les blocs chiﬀrés possibles.
      </li>
      <li class="itemize">les octets pseudo aléatoires peuvent aussi aider à contrecarrer une attaque grâce à Coppersmith et
      al. quand la taille du message à chiﬀrer est gardé petit. L&#x2019;attaque marche sur les petits exposants
      RSA quand des messages similaires sont chiﬀrés avec la même clef publique. Plus spéciﬁquement,
      une façon peut être, quand deux entrées RSAEP correspondent sur une large portion de bits (8/9) et
      qu&#x2019;un petit exposant RSA est utilisé (e = 3) pour chiﬀrer les deux, il peut être possible de retrouver
      les entrées avec l&#x2019;attaque. Une autre façon d&#x2019;attaquer est couronnée de succès pour déchiﬀrer un
      seul texte chiﬀré, quand une large proportion (2/3) des entrées de RSAEP est déjà connue. Pour
      des applications typiques, le message à chiﬀrer est court (par exemple une clef symétrique de 128
      bits) donc peu d&#x2019;informations seront connues ou en commun entre deux messages pour permettre
      l&#x2019;attaque. Cependant, si un long message est chiﬀré, ou si une partie du message est connu, alors
      l&#x2019;attaque peut fonctionner. Dans tous les cas, le schéma RSAES-OAEP surmonte l&#x2019;attaque.<br 
class="newline" /></li></ul>
<a 
 id="x10-138001r146"></a>
<h5 class="subsubsectionHead"><span class="titlemark">3.2.1.2   </span> <a 
href="#x10-1390002" id="x10-1390002">Faille</a></h5>
     RSA-OAEP peut être soumis à une attaque nommée &#x0022;Mangers Attack&#x0022; selon son implantation <span class="cite">[<span 
class="ec-lmbx-10x-x-109">?</span>]</span>. OpenSSL
semble être vulnérable à une attaque de ce type, à base de &#x0022;prédictions&#x0022; par injections de fautes. La vulnérabilité
semble être très récente puisqu&#x2019;elle fonctionne sous OpenSSL 1.0.0.<br 
class="newline" />
   Le padding OAEP devait palier le problème d&#x2019;insécurité que causait le padding PKCS#1 v1.5 (attaque à chiﬀré
choisi) <span class="cite">[<span 
class="ec-lmbx-10x-x-109">?</span>]</span>. OpenSSL a tout de même pris en compte cette vulnérabilité et a placé des contres-mesures eﬃcaces. La
Technische Universität Darmstadt (Allemagne) explique en détails comment sont implémentées ces
contre-mesures et montre que dans certains cas l&#x2019;attaque reste possible. Enﬁn, elle apporte ses propres
contre-mesures.<br 
class="newline" />
   On peut noter que plusieurs librairies sont vulnérables à une attaque de Manger qui consiste à contrôler la taille
des paramètres à hacher, mais que l&#x2019;implantation de RSA-OAEP d&#x2019;OpenSSL ne le permet pas. La raison est que le
décodage OAEP est linéaire quelle que soit la taille des paramètres et les erreurs survenues. Il semble également y
avoir un problème avec l&#x2019;OAEP_padding sur le chiﬀrement RSA. Bill Nickless recommande l&#x2019;utilisation de
PKCS_padding. <span class="cite">[<span 
class="ec-lmbx-10x-x-109">?</span>]</span> <br 
class="newline" />
<a 
 id="x10-139001r159"></a>
<h5 class="subsubsectionHead"><span class="titlemark">3.2.1.3   </span> <a 
href="#x10-1400003" id="x10-1400003">Implémentation</a></h5>
<!--l. 251--><p class="noindent" ><span class="paragraphHead"><a 
href="#x10-1410003" id="x10-1410003"><span 
class="ec-lmbx-10x-x-109">Conﬁguration vis</span><span 
class="ec-lmbx-10x-x-109">ée.</span><br 
class="newline" /></a></span>
   L&#x2019;étude a été réalisée sur la librairie OpenSSL-1.0.0.
</p>
<!--l. 255--><p class="noindent" ><span class="paragraphHead"><a 
href="#x10-1420003" id="x10-1420003"><span 
class="ec-lmbx-10x-x-109">Fonction.</span><br 
class="newline" /></a></span>
                                                                                                  

                                                                                                  
   La fonction auditée se nomme RSA_padding_check_PKCS1_OAEP() (cf. <span 
class="ec-lmri-10x-x-109">Listing </span><a 
href="#x10-142001r1">3.1<!--tex4ht:ref: rsaoaep --></a>) et est accessible à partir
du chemin <span 
class="ec-lmtt-10x-x-109">openssl/crypto/rsa/rsa_oaep.c</span>.
</p>
   <!--l. 260-->
<pre>
lzero = num - flen; 
if (lzero < 0) 
{ 
/* signalling this error immediately after detection might allow 
* for side-channel attacks (e.g. timing if ’plen’ is huge 
* -- cf. James H. Manger, "A Chosen Ciphertext Attack on RSA 
Optimal 
* Asymmetric Encryption Padding (OAEP) [...]", CRYPTO 2001), 
* so we use a ’bad’ flag */ 
bad = 1; 
lzero = 0; 
flen = num; /* don’t overflow the memcpy to padded_from */ 
} 
</pre>
       <div class="caption" 
><span class="id">Listing 3.1:
       </span><span  
class="content">rsa_oaep.c</span></div><!--tex4ht:label?: x10-142001r3 -->
<!--l. 277--><p class="indent" >   Le développeur n&#x2019;a pas considéré qu&#x2019;il y avait un grand danger dans le code de contre-mesures.<br 
class="newline" />Pourtant l&#x2019;étude conﬁrme qu&#x2019;il y a un décalage de temps possible, certes léger mais qui peut entraîner une attaque
en &#x0022;branch prediction&#x0022; (qui peut se traduire en prédiction par dérivation).<br 
class="newline" />
<a 
 id="x10-142016r160"></a>
</p>
<h5 class="subsubsectionHead"><span class="titlemark">3.2.1.4   </span> <a 
href="#x10-1430004" id="x10-1430004">Conclusion</a></h5>
     Il n&#x2019;y a pas vraiment de quoi s&#x2019;alarmer, cette attaque est en pratique infaisable sur un serveur car il y a
suﬃsamment de variations de délais (diﬀérences de CPU, opérations multi-tâches, connexions réseaux, etc...) pour
éviter une attaque par timing. Cependant, sur des systèmes embarqués l&#x2019;attaque peut être réalisable, et il serait
plus prudent de palier ce problème.
<a 
 id="x10-143001r145"></a>
<h4 class="subsectionHead"><span class="titlemark">3.2.2   </span> <a 
href="#x10-1440002" id="x10-1440002">Audit 3.2<span class="frenchb-nbsp">&nbsp;</span>: Chiﬀrement SSLv3 ou TLS 1.0 en mode CBC</a></h4>
<a 
 id="x10-144001r164"></a>
<h5 class="subsubsectionHead"><span class="titlemark">3.2.2.1   </span> <a 
href="#x10-1450001" id="x10-1450001">Normes visées</a></h5>
<!--l. 287--><p class="noindent" ><span class="paragraphHead"><a 
href="#x10-1460001" id="x10-1460001"><span 
class="ec-lmbx-10x-x-109">SSL version 3 </span><br 
class="newline" /></a></span>
   Cette partie référence la RFC 6101 <span class="cite">[<span 
class="ec-lmbx-10x-x-109">?</span>]</span> du protocole SSL version 3, concernant le chiﬀrement par bloc.
<br 
class="newline" />Dans ce chiﬀrement, chaque bloc de texte clair est chiﬀré dans un bloc de donnée chiﬀrée. Comme il est très peu
probable que le texte clair (qu&#x2019;importe la donnée à envoyer) ne se découpe exactement en taille de blocs nécessaire
(qui est de 64 bits normalement), on doit alors rajouter du bourrage à la ﬁn de ces petit blocs avec des valeurs
régulières, normalement des &#x2019;0&#x2019;. <br 
class="newline" />
</p><!--l. 291--><p class="indent" >   Lorsqu&#x2019;un chiﬀrement CBC est utilisé, un vecteur d&#x2019;initialisation (IV) est maintenu pour chaque clef. Cette
valeur est initialisée pour la première fois par la poignée de main du protocole SSL. Par la suite, le dernier bloc du
texte chiﬀré de chaque tour est préservé comme IV pour le tour suivant.<br 
class="newline" />
                                                                                                  

                                                                                                  
</p>
<pre>
block-ciphered struct {
    opaque content[SSLCompressed.length];
    opaque MAC[CipherSpec.hash_size];
    uint8 padding[GenericBlockCipher.padding_length];
    uint8 padding_length;
} GenericBlockCipher;
</pre>
<!--l. 300--><p class="nopar" >
</p>
   <div class="tabular"> <table id="TBL-6" class="tabular" 
cellspacing="0" cellpadding="0"  
><colgroup id="TBL-6-1g"><col 
id="TBL-6-1" /><col 
id="TBL-6-2" /><col 
id="TBL-6-3" /></colgroup><tr  
 style="vertical-align:baseline;" id="TBL-6-1-"><td  style="white-space:nowrap; text-align:left;" id="TBL-6-1-1"  
class="td11"> - <span 
class="ec-lmtt-10x-x-109">content       </span></td><td  style="white-space:nowrap; text-align:left;" id="TBL-6-1-2"  
class="td11"> <span class="frenchb-nbsp">&nbsp;</span>:  </td><td  style="white-space:nowrap; text-align:left; vertical-align:middle;" id="TBL-6-1-3"  
class="td11"> <!--l. 303--><p class="noindent" >le contenu du bloc de message.                                       </p></td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-6-2-"><td  style="white-space:nowrap; text-align:left;" id="TBL-6-2-1"  
class="td11"> - <span 
class="ec-lmtt-10x-x-109">MAC            </span></td><td  style="white-space:nowrap; text-align:left;" id="TBL-6-2-2"  
class="td11"> <span class="frenchb-nbsp">&nbsp;</span>:  </td><td  style="white-space:nowrap; text-align:left; vertical-align:middle;" id="TBL-6-2-3"  
class="td11"> <!--l. 304--><p class="noindent" >la valeur du haché MAC.                                              </p></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-6-3-"><td  style="white-space:nowrap; text-align:left;" id="TBL-6-3-1"  
class="td11"> - <span 
class="ec-lmtt-10x-x-109">padding </span></td> <td  style="white-space:nowrap; text-align:left;" id="TBL-6-3-2"  
class="td11"> <span class="frenchb-nbsp">&nbsp;</span>: </td> <td  style="white-space:nowrap; text-align:left; vertical-align:middle;" id="TBL-6-3-3"  
class="td11"> <!--l. 305--><p class="noindent" >le bourage qui est utilisé pour forcer la taille du bloc.</p></td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-6-4-"><td  style="white-space:nowrap; text-align:left;" id="TBL-6-4-1"  
class="td11"> - <span 
class="ec-lmtt-10x-x-109">padding_length </span></td><td  style="white-space:nowrap; text-align:left;" id="TBL-6-4-2"  
class="td11"> <span class="frenchb-nbsp">&nbsp;</span>:  </td><td  style="white-space:nowrap; text-align:left; vertical-align:middle;" id="TBL-6-4-3"  
class="td11"> <!--l. 306--><p class="noindent" >la taille du bourage utilisé qui doit être plus petit que la     </p></td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-6-5-"><td  style="white-space:nowrap; text-align:left;" id="TBL-6-5-1"  
class="td11">                 </td><td  style="white-space:nowrap; text-align:left;" id="TBL-6-5-2"  
class="td11">   </td><td  style="white-space:nowrap; text-align:left; vertical-align:middle;" id="TBL-6-5-3"  
class="td11"> <!--l. 307--><p class="noindent" >taille du bloc chiﬀré et il peut être à &#x2019;0&#x2019;.                           </p></td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-6-6-"><td  style="white-space:nowrap; text-align:left;" id="TBL-6-6-1"  
class="td11">                 </td> </tr></table></div><br 
class="newline" />
<!--l. 311--><p class="indent" >   La taille des données chiﬀrées (<span 
class="ec-lmtt-10x-x-109">SSLCiphertext.length</span>) est égale à la somme de <span 
class="ec-lmtt-10x-x-109">SSLCompressed.length</span>,
<span 
class="ec-lmtt-10x-x-109">CipherSpec.hash_size </span>et <span 
class="ec-lmtt-10x-x-109">padding_length </span>+ 1.
</p>
<!--l. 313--><p class="noindent" ><span class="paragraphHead"><a 
href="#x10-1470001" id="x10-1470001"><span 
class="ec-lmbx-10x-x-109">CBC</span><span class="frenchb-nbsp">&nbsp;</span><span 
class="ec-lmbx-10x-x-109">: </span><span 
class="ec-lmbxi-10x-x-109">Cipher Block Chaining </span><br 
class="newline" /></a></span>
   C&#x2019;est un mode de chiﬀrement qui a été très utilisé<span class="frenchb-nbsp">&nbsp;</span>: enchaînement des blocs.<br 
class="newline" />Sur chaque bloc, un OU exclusif avec le chiﬀrement du bloc précédent est appliqué. Un vecteur d&#x2019;initialisation est
lui aussi utilisé. Contrairement au mode ECB, les blocs identiques ne seront pas chiﬀrés de la même façon. On ne
pourra donc pas repérer de chaîne de caractères récurrentes aussi facilement. Ce mode de chiﬀrement possède
plusieurs inconvénients<span class="frenchb-nbsp">&nbsp;</span>: </p>
      <ul class="itemize1">
      <li class="itemize">un  chiﬀrement  de  plusieurs  blocs  en  parallèles  est  impossible  (puisque  chaque  bloc  dépend  du
      chiﬀrement du précédent). Déchiﬀrer avec un IV incorrect entraînera une corruption dans le premier
      bloc en clair, mais les blocs suivants seront corrects. C&#x2019;est parce qu&#x2019;un texte clair peut être récupéré
      grâce à deux blocs adjacents du texte chiﬀré. Le déchiﬀrement, contrairement au chiﬀrement, peut
      donc être parallélisé. À noter que si un seul bit change dans le texte chiﬀré, le bloc clair correspondant
      est complètement corrompu.
      </li>
      <li class="itemize">Si une erreur se produit sur un bloc, elle sera répercutée sur tous les suivants. La propagation d&#x2019;erreur
      n&#x2019;est pas limitée.</li></ul>
<hr class="figure" /><div class="figure" 
><a 
 id="x10-147001r3"></a> <img 
src="audit/images/CBC_chiff.png" alt="PIC"  
 />
<br /> <div class="caption" 
><span class="id"><span 
class="ec-lmcsc-10x-x-109">Figure</span> 3.3: </span><span  
class="content">Chiﬀrement CBC</span></div><!--tex4ht:label?: x10-147001r3 -->
   </div><hr class="endfigure" />
   <hr class="figure" /><div class="figure" 
>
                                                                                                  

                                                                                                  
<a 
 id="x10-147002r4"></a><a 
 id="x11-164001r15"></a><a 
 id="x11-167001r13"></a><a 
 id="x11-175001r38"></a>
                                                                                                  

                                                                                                  

<!--l. 329--><p class="noindent" ><img 
src="audit/images/CBC_dechiff.png" alt="PIC"  
 />
<br /> </p><div class="caption" 
><span class="id"><span 
class="ec-lmcsc-10x-x-109">Figure</span> 3.4: </span><span  
class="content">Déchiﬀrement CBC</span></div><!--tex4ht:label?: x10-147002r4 -->
                                                                                                  

                                                                                                  
   </div><hr class="endfigure" />
<!--l. 334--><p class="indent" >   Il a d&#x2019;abord été déﬁni par le NIST dans le FIPS 81 (<a 
href="http://www.itl.nist.gov/fipspubs/fip81.htm" class="url" ><span 
class="ec-lmtt-10x-x-109">http://www.itl.nist.gov/fipspubs/fip81.htm</span></a>). Le
standard a été publié en 1981.
<a 
 id="x10-147003r166"></a>
</p>
<h5 class="subsubsectionHead"><span class="titlemark">3.2.2.2   </span> <a 
href="#x10-1480002" id="x10-1480002">Description de la faille</a></h5>
<!--l. 338--><p class="noindent" >En Septembre 2011, une attaque en <span 
class="ec-lmri-10x-x-109">man in the middle </span>très eﬃcace a vu le jour contre les protocoles SSLv3 et
TLS 1.0. <span class="cite">[<span 
class="ec-lmbx-10x-x-109">?</span>]</span> <span class="cite">[<span 
class="ec-lmbx-10x-x-109">?</span>]</span> <span class="cite">[<span 
class="ec-lmbx-10x-x-109">?</span>]</span> <span class="cite">[<span 
class="ec-lmbx-10x-x-109">?</span>]</span>. L&#x2019;attaque est à clair choisi. Le but étant d&#x2019;insérer des morceaux de texte clair
grâce au navigateur dans la requête chiﬀrée avec ces protocoles, ceci aﬁn de récupérer les cookies de
session.<br 
class="newline" />
</p><!--l. 340--><p class="indent" >   La technique est basique, un individu enregistre plusieurs cookies de session auprès de divers sites oﬃciels
(banques, messageries, etc...). Puis, il clique malencontreusement sur du code Java malveillant (publicité, image,
etc...). et l&#x2019;attaque se déroule automatiquement. L&#x2019;ensemble des cookies est envoyé au serveur malveillant qui n&#x2019;a
plus qu&#x2019;à déchiﬀrer les clés de session.<br 
class="newline" />
</p><!--l. 342--><p class="indent" >   La cause viendrait du mode de chiﬀrement choisi<span class="frenchb-nbsp">&nbsp;</span>: CBC. SSL/TLS est un protocole qui chiﬀre un canal de
communication. De ce fait il ne chiﬀre pas un ﬁchier unique, mais une série d&#x2019;enregistrements. Il y a deux façons
d&#x2019;utiliser le mode CBC dans ce cas précis<span class="frenchb-nbsp">&nbsp;</span>: </p>
      <ul class="itemize1">
      <li class="itemize">prendre chacun de ces enregistrements indépendamment des autres. Générer un nouveau vecteur
      d&#x2019;initialisation à chaque fois<span class="frenchb-thinspace">&nbsp;</span>;
      </li>
      <li class="itemize">traiter ces enregistrements comme un seul objet en les concaténant. Le vecteur d&#x2019;initialisation est
      donc choisi aléatoirement pour le premier enregistrement et pour les autres, il aura pour valeur le
      dernier bloc de l&#x2019;enregistrement précédent.<br 
class="newline" />
      </li></ul>
<!--l. 349--><p class="indent" >   SSLv3 et TLS 1.0 utilisent ce deuxième choix, cela soulève un lourd problème de sécurité. En 2004, Moeller <span class="cite">[<span 
class="ec-lmbx-10x-x-109">?</span>]</span>
trouve une méthode pour exploiter ce mauvais choix aﬁn de récupérer des morceaux de textes clairs. Il y a certes
une faille immense, mais peu exploitable. Les grandes entreprises savent (normalement) qu&#x2019;il ne faut pas utiliser le
mode CBC pour du chiﬀrement SSL/TLS. Et, dans tous les cas, plusieurs navigateurs ne permettent pas ce type
d&#x2019;attaque (c&#x2019;est le cas de Chrome par exemple).
<a 
 id="x10-148001r171"></a>
</p>
<h5 class="subsubsectionHead"><span class="titlemark">3.2.2.3   </span> <a 
href="#x10-1490003" id="x10-1490003">Tests</a></h5>
<!--l. 353--><p class="noindent" >Nous n&#x2019;avons pas repris les tests du logiciel BEAST qui s&#x2019;avère être introuvable sur le Web (celui-ci étant un projet
universitaire, développé par un étudiant de l&#x2019;Université de Versailles). Mais une vidéo de l&#x2019;exploit est accessible sur
YouTube au lien ci-dessous<span class="frenchb-nbsp">&nbsp;</span>: <br 
class="newline" />
</p><!--l. 355--><p class="indent" >   <span 
class="ec-lmbx-10x-x-109">Lien YouTube</span><span class="frenchb-nbsp">&nbsp;</span><span 
class="ec-lmbx-10x-x-109">:  </span><a 
href="http://www.youtube.com/watch?v=ujz4SXzWK9o" >http://www.youtube.com/watch?v=ujz4SXzWK9o</a>
<a 
 id="x10-149001r172"></a>
</p>
                                                                                                  

                                                                                                  
<h5 class="subsubsectionHead"><span class="titlemark">3.2.2.4   </span> <a 
href="#x10-1500004" id="x10-1500004">Recommandations</a></h5>
<!--l. 359--><p class="noindent" >La faille existe tant que l&#x2019;association de ces protocoles avec le mode de chiﬀrement CBC existe. Même si l&#x2019;attaque
est infaisable sur les navigateurs les plus répandus (Chrome, Firefox, IE, Safari, ...), OpenSSL devrait pouvoir
interdire cette association, et ne pas laisser le travail aux navigateurs. Mais rien n&#x2019;empêche l&#x2019;utilisation de ce
chiﬀrement par un navigateur plus léger, nous pourrons tester cette vulnérabilité lors de notre partie 3 si nous
trouvons un navigateur acceptant ce type de chiﬀrement.
<a 
 id="x10-150001r165"></a>
</p>
<h4 class="subsectionHead"><span class="titlemark">3.2.3   </span> <a 
href="#x10-1510003" id="x10-1510003">Audit 3.3<span class="frenchb-nbsp">&nbsp;</span>: Non-validation des certiﬁcats SSL</a></h4>
<a 
 id="x10-151001r173"></a>
<h5 class="subsubsectionHead"><span class="titlemark">3.2.3.1   </span> <a 
href="#x10-1520001" id="x10-1520001">Normes visées</a></h5>
<!--l. 364--><p class="noindent" ><span class="paragraphHead"><a 
href="#x10-1530001" id="x10-1530001"><span 
class="ec-lmbx-10x-x-109">RFC 5246 </span><br 
class="newline" /></a></span>
   La RFC 5246 <span class="cite">[<span 
class="ec-lmbx-10x-x-109">?</span>]</span> stipule que le serveur doit toujours envoyer un message certiﬁcat dès lors que la méthode
d&#x2019;échange des clefs a été acceptée. Le certiﬁcat DOIT être approprié à la suite des chiﬀrements utilisés pour les
échanges de clefs. La structure du message est<span class="frenchb-nbsp">&nbsp;</span>:
                                                                                                  

                                                                                                  
</p>
   <pre>
opaque ASN.1Cert&#x003C;1..2^24-1&#x003E;;
struct {
  ASN.1Cert certificate_list&#x003C;0..2^24-1&#x003E;;
} Certificate;
</pre>
<!--l. 374--><p class="nopar" >
</p><!--l. 376--><p class="indent" >   La liste de certiﬁcats (<span 
class="ec-lmtt-10x-x-109">certificate_list</span>) est une séquence de certiﬁcats. Le certiﬁcat de l&#x2019;envoyeur DOIT
venir en premier. Les suivants sont ceux qui forment la chaîne de certiﬁcation. Les certiﬁcats auto-signés qui
spéciﬁent un certiﬁcat racine peuvent être omis de la chaîne, sous condition que le certiﬁcat à l&#x2019;extrémité de la
chaîne soit dans tous les cas validé.<br 
class="newline" />
</p><!--l. 378--><p class="indent" >   Le même message type et la même structure seront utilisés pour la réponse au client du message de requête de
certiﬁcat.
<a 
 id="x10-153001r175"></a>
</p>
<h5 class="subsubsectionHead"><span class="titlemark">3.2.3.2   </span> <a 
href="#x10-1540002" id="x10-1540002">Description de la faille</a></h5>
     Six chercheurs des universités de Stanford et d&#x2019;Austin au Texas, analysent une attaque en Man in the Middle
autour des certiﬁcats SSL sans utilisation d&#x2019;un navigateur. Le titre est sans appel &#x0022;Le code le plus dangereux du
monde&#x0022; <span class="cite">[<span 
class="ec-lmbx-10x-x-109">?</span>]</span>.<br 
class="newline" />
   SSL doit permettre d&#x2019;être sécurisé en toutes circonstances, que le cache DNS soit empoisonné, que les
attaquants contrôlent les points d&#x2019;accès et les routeurs, etc. Il assure théoriquement trois grands principes de la
cryptologie<span class="frenchb-nbsp">&nbsp;</span>: la conﬁdentialité, l&#x2019;intégrité et l&#x2019;authentiﬁcation. Nous connaissons certaines failles au niveau du
navigateur et de l&#x2019;implantation SSL (voir ci-dessus). Mais il existe également d&#x2019;autres cas d&#x2019;utilisation du protocole
SSL. Par exemple<span class="frenchb-nbsp">&nbsp;</span>:
      <ul class="itemize1">
      <li class="itemize">administration à distance basé sur le cloud, stockage sécurisé sur le cloud en local<span class="frenchb-thinspace">&nbsp;</span>;
      </li>
      <li class="itemize">transmissions de données sensibles (ex<span class="frenchb-nbsp">&nbsp;</span>: e-commerce)<span class="frenchb-thinspace">&nbsp;</span>;
      </li>
      <li class="itemize">services en ligne comme les messageries électroniques<span class="frenchb-thinspace">&nbsp;</span>;
      </li>
      <li class="itemize">authentiﬁcation via applications mobiles comme Android et iOS.<br 
class="newline" /></li></ul>
<!--l. 394--><p class="noindent" >L&#x2019;étude montre que la validation des certiﬁcats SSL est basée sur plusieurs applications et librairies dont<span class="frenchb-nbsp">&nbsp;</span>:
</p>
      <ul class="itemize1">
      <li class="itemize">OpenSSL
      </li>
      <li class="itemize">JSSE
                                                                                                  

                                                                                                  
      </li>
      <li class="itemize">CryptoAPI
      </li>
      <li class="itemize">NSS
      </li>
      <li class="itemize">GnuTLS
      </li>
      <li class="itemize">etc...<br 
class="newline" /></li></ul>
<!--l. 404--><p class="indent" >   En fait, un attaquant en <span 
class="ec-lmri-10x-x-109">Man In The Middle </span>peut intercepter le secret entre un client et un serveur utilisant une
connexion SSL. Il peut ainsi récupérer des numéros de carte bancaire, avoir accès à une messagerie, récupérer des
mots de passe, etc. La cause principale vient du fait que les développeurs retouchent les librairies cryptographiques
à leur façon. En voulant réparer un bug ou en souhaitant rendre SSL compatible avec leurs API, ils injectent de
nouvelles vulnérabilités. De plus, l&#x2019;application est souvent propriétaire et payante ce qui rend le déboggage
diﬃcile.<br 
class="newline" />
</p><!--l. 407--><p class="indent" >   Que ce soit accidentel ou intentionnel, l&#x2019;une des conséquences les plus graves est la non-validation
de certiﬁcat sur des contextes où la sécurité est primordiale (e.g. payement en ligne). La faute ne
revient pas directement au code d&#x2019;OpenSSL, mais à une mauvaise utilisation des diﬀérentes fonctions et
options.<br 
class="newline" />
</p><!--l. 410--><p class="indent" >   Voici quelques exemples concrets concernant diﬀérentes API<span class="frenchb-nbsp">&nbsp;</span>: </p>
      <ul class="itemize1">
      <li class="itemize">les services comme Amazon&#x2019;s Flexible Payments Service PHP et PayPal Payments Standard PHP
      passent le paramètre <span 
class="ec-lmtt-10x-x-109">CURLOPT_SSL_VERIFYHOST </span>à <span 
class="ec-lmri-10x-x-109">true </span>alors que la valeur doit être passée à 2. La
      conséquence est la désactivation de la validation du certiﬁcat<span class="frenchb-thinspace">&nbsp;</span>;
      </li>
      <li class="itemize">lynx, un navigateur textuel très connu et souvent utilisé dans le développement d&#x2019;applications, vériﬁe
      les certiﬁcats auto-signés seulement si la fonction de validation de certiﬁcat GnuTLS retourne une
      valeur négative. Malheureusement, dans certains cas la fonction peut retourner 0 pour certaines
      erreurs (dont les certiﬁcats signés par une autorité sans conﬁance)<span class="frenchb-thinspace">&nbsp;</span>;
      </li>
      <li class="itemize">la librairie SSLSocketFactory de JSSE, très réputée, ne fait pas de vériﬁcation si la cypher suite du
      client vaut NULL ou est une chaîne vide<span class="frenchb-thinspace">&nbsp;</span>;
      </li>
      <li class="itemize">vulnérabilités sur Apache HttpClient, WebSockets, Android, ...<span class="frenchb-thinspace">&nbsp;</span>;
      </li>
      <li class="itemize">autres causes célèbres<span class="frenchb-nbsp">&nbsp;</span>: non reconnaissance des expressions régulières, non vériﬁcation du résultat de
      la validation, désactivation de l&#x2019;authentiﬁcation.<br 
class="newline" /></li></ul>
<a 
 id="x10-154001r177"></a>
<h5 class="subsubsectionHead"><span class="titlemark">3.2.3.3   </span> <a 
href="#x10-1550003" id="x10-1550003">Diﬃcultés du code OpenSSL</a></h5>
<!--l. 423--><p class="noindent" >OpenSSL ne déroge pas à la règle.<br 
class="newline" />Voici quelques vulnérabilités du code<span class="frenchb-nbsp">&nbsp;</span>: </p>
                                                                                                  

                                                                                                  
      <ul class="itemize1">
      <li class="itemize">les contraintes de nom x509 ne sont pas correctement validés<span class="frenchb-thinspace">&nbsp;</span>;
      </li>
      <li class="itemize">les applications DOIVENT fournir elles même leur code de vériﬁcation de nom d&#x2019;hôte. Or, des
      protocoles comme HTTPS, LDAP ont chacun leurs propres notions de validations. Ainsi, Apache
      Libcloud utilise les librairies Python, elles-même utilisant des commandes OpenSSL. Et sa méthode
      de vériﬁcation du nom d&#x2019;hôte comporte des vulnérabilités pouvant causer des attaques en <span 
class="ec-lmri-10x-x-109">Man in</span>
      <span 
class="ec-lmri-10x-x-109">the Middle </span>(e.g &#x0022;google.com&#x0022; et &#x0022;oogle.com&#x0022; vériﬁe la même expression régulière)<span class="frenchb-thinspace">&nbsp;</span>;
      </li>
      <li class="itemize">un programme utilisant OpenSSL peut exécuter la fonction <span 
class="ec-lmtt-10x-x-109">SSL_connect </span>pour le handshake SSL.
      Bien que certaines erreurs de validation soient signalées par <span 
class="ec-lmtt-10x-x-109">SSL_connect</span>, d&#x2019;autres ne peuvent être
      vériﬁées qu&#x2019;en appelant la fonction <span 
class="ec-lmtt-10x-x-109">SSL_get_verify_result</span>, alors que <span 
class="ec-lmtt-10x-x-109">SSL_connect </span>se contente de
      retourner &#x0022;OK&#x0022;.<br 
class="newline" /></li></ul>
<a 
 id="x10-155001r178"></a>
<h5 class="subsubsectionHead"><span class="titlemark">3.2.3.4   </span> <a 
href="#x10-1560004" id="x10-1560004">Exemple<span class="frenchb-nbsp">&nbsp;</span>: Trillian</a></h5>
<!--l. 433--><p class="noindent" >Trillian est une messagerie cliente instantanée reliée à OpenSSL pour la sécurisation de l&#x2019;établissement de
connexion. Par défaut OpenSSL ne soulève pas d&#x2019;exception en cas de certiﬁcat auto-signé ou de non-conﬁance
auprès de la chaîne de vériﬁcation. À la place, il envoie un drapeau. De plus, il ne vériﬁe jamais le nom d&#x2019;hôte. Si
l&#x2019;application appelle la fonction <span 
class="ec-lmtt-10x-x-109">SSL_CTX_set </span>pour initialiser le drapeau <span 
class="ec-lmtt-10x-x-109">SSL_VERIFY_PEER</span>, alors <span 
class="ec-lmtt-10x-x-109">SSL_connect </span>se
ferme et aﬃche un message d&#x2019;erreur lorsque le certiﬁcat n&#x2019;est pas valide. Mais Trillian n&#x2019;initialise jamais ce drapeau.
Par conséquent, <span 
class="ec-lmtt-10x-x-109">SSL_connect </span>va retourner 1 et le statut de la validation du certiﬁcat peut être connu en appelant
la fonction <span 
class="ec-lmtt-10x-x-109">SSL_get_verify_result</span>. Encore une fois, Trillian n&#x2019;appelle pas cette fonction. Les conséquences sont
très lourdes<span class="frenchb-nbsp">&nbsp;</span>: vols de mots de passe, compromissions de services, révélations des paramètres de sécurité,
etc...<br 
class="newline" />
</p><!--l. 436--><p class="indent" >   L&#x2019;étude montre que l&#x2019;attaque est possible sur la version 5.1.0.19 et antérieure de Trillian.
<a 
 id="x10-156001r179"></a>
</p>
<h5 class="subsubsectionHead"><span class="titlemark">3.2.3.5   </span> <a 
href="#x10-1570005" id="x10-1570005">Conclusion</a></h5>
<!--l. 440--><p class="noindent" >Les chercheurs nous donnent alors plusieurs leçons à retenir, dont voici quelques points<span class="frenchb-nbsp">&nbsp;</span>: </p>
      <ul class="itemize1">
      <li class="itemize">premièrement, les vulnérabilités doivent être trouvées et réparées lors des phases de tests. Certaines
      se trouvent très facilement si les procédures de tests sont bien réalisées<span class="frenchb-thinspace">&nbsp;</span>;
      </li>
      <li class="itemize">deuxièmement, la plupart des librairies SSL ne sont pas <span 
class="ec-lmbx-10x-x-109">s</span><span 
class="ec-lmbx-10x-x-109">ûres par d</span><span 
class="ec-lmbx-10x-x-109">éfaut</span>, laissant le choix de la
      sécurité aux applications de plus haut niveau avec choix des options, choix de la vériﬁcation de l&#x2019;hôte,
      choix d&#x2019;interprétation des résultats<span class="frenchb-thinspace">&nbsp;</span>;
      </li>
      <li class="itemize">troisièmement,  même  les  librairies  SSL  sûres  par  défaut  peuvent  être  mal  utilisées  par  des
      développeurs changeant les paramètres par défaut par des paramètres non sécurisés. La cause peut
      venir d&#x2019;une <span 
class="ec-lmbx-10x-x-109">mauvaise documentation </span>ou d&#x2019;une mauvaise formalisation de la part de l&#x2019;API. Les
      API devraient entre autres proposer des abstractions de haut niveau pour les développeurs comme
      des tunnels d&#x2019;authentiﬁcation, plutôt que de les laisser traiter des détails de bas niveau comme la
                                                                                                  

                                                                                                  
      vériﬁcation du nom d&#x2019;hôte.<br 
class="newline" /></li></ul>
<!--l. 447--><p class="indent" >   Nous conseillons surtout une meilleure documentation d&#x2019;OpenSSL, et des rapports d&#x2019;erreurs d&#x2019;interfaces plus
simples et plus consistants aﬁn d&#x2019;éviter les erreurs d&#x2019;interprétation. L&#x2019;idée des chercheurs de proposer des
abstractions de haut niveau pour les applications semblent être une très bonne idée.
                                                                                                  

                                                                                                  
                                                                                                  

                                                                                                  
                                                                                                  

                                                                                                  
</p>
